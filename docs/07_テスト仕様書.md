# テスト仕様書 - Asset Allocation Tool

## 1. テスト戦略

### 1.1 テストピラミッド
```
         E2E Tests (10%)
        /            \
    Integration Tests (30%)
   /                      \
    Unit Tests (60%)
```

### 1.2 カバレッジ目標
- **Overall Coverage**: 80%以上
- **Critical Path Coverage**: 95%以上
- **Unit Test Coverage**: 90%以上
- **Integration Test Coverage**: 70%以上
- **E2E Test Coverage**: Critical paths only

### 1.3 テスト環境
| 環境 | 用途 | データベース | API |
|-----|-----|-----------|-----|
| Local | 開発時テスト | SQLite/Mock | Mock |
| CI | 自動テスト | PostgreSQL (Docker) | Mock |
| Staging | 統合テスト | PostgreSQL | Sandbox API |
| Production | Smoke test | PostgreSQL | Production API |

## 2. Unit Tests

### 2.1 計算ロジックテスト

#### Portfolio Calculations
```typescript
// tests/unit/calculations/portfolio.test.ts
import { describe, it, expect } from '@jest/globals'
import {
  calculateReturns,
  calculateVolatility,
  calculateSharpeRatio,
  calculateMaxDrawdown,
  calculateBeta,
  calculateCorrelation,
} from '@/lib/calculations/portfolio'

describe('Portfolio Calculations', () => {
  describe('calculateReturns', () => {
    it('should calculate simple returns correctly', () => {
      const prices = [100, 105, 110, 108, 115]
      const returns = calculateReturns(prices)
      expect(returns).toEqual([0.05, 0.0476, -0.0182, 0.0648])
    })

    it('should handle empty array', () => {
      expect(calculateReturns([])).toEqual([])
    })

    it('should handle single value', () => {
      expect(calculateReturns([100])).toEqual([])
    })
  })

  describe('calculateSharpeRatio', () => {
    it('should calculate Sharpe ratio correctly', () => {
      const returns = [0.01, 0.02, -0.01, 0.03, 0.015]
      const riskFreeRate = 0.02
      const sharpe = calculateSharpeRatio(returns, riskFreeRate, 252)
      expect(sharpe).toBeCloseTo(0.45, 2)
    })

    it('should return 0 for zero volatility', () => {
      const returns = [0.01, 0.01, 0.01, 0.01]
      const sharpe = calculateSharpeRatio(returns, 0.01, 252)
      expect(sharpe).toBe(0)
    })

    it('should handle negative Sharpe ratio', () => {
      const returns = [-0.01, -0.02, -0.015, -0.03]
      const sharpe = calculateSharpeRatio(returns, 0.02, 252)
      expect(sharpe).toBeLessThan(0)
    })
  })

  describe('calculateMaxDrawdown', () => {
    it('should calculate maximum drawdown correctly', () => {
      const values = [100, 120, 110, 90, 95, 100, 85, 95]
      const maxDD = calculateMaxDrawdown(values)
      expect(maxDD).toBeCloseTo(-0.2917, 4) // -29.17%
    })

    it('should return 0 for ascending values', () => {
      const values = [100, 110, 120, 130, 140]
      expect(calculateMaxDrawdown(values)).toBe(0)
    })

    it('should handle empty array', () => {
      expect(calculateMaxDrawdown([])).toBe(0)
    })
  })
})
```

#### Optimization Tests
```typescript
// tests/unit/calculations/optimization.test.ts
import {
  optimizeMaxSharpe,
  optimizeMinVariance,
  optimizeRiskParity,
  calculateEfficientFrontier,
} from '@/lib/calculations/optimization'

describe('Portfolio Optimization', () => {
  const mockReturns = [
    [0.01, 0.02, -0.01, 0.03],
    [0.015, -0.005, 0.02, 0.01],
    [0.005, 0.01, 0.015, -0.01],
  ]

  describe('optimizeMaxSharpe', () => {
    it('should return valid weights', () => {
      const weights = optimizeMaxSharpe(mockReturns)
      expect(weights).toHaveLength(3)
      expect(weights.every(w => w >= 0 && w <= 1)).toBe(true)
      expect(Math.abs(weights.reduce((a, b) => a + b, 0) - 1)).toBeLessThan(0.001)
    })

    it('should handle constraints', () => {
      const constraints = {
        minWeight: 0.1,
        maxWeight: 0.5,
      }
      const weights = optimizeMaxSharpe(mockReturns, constraints)
      expect(weights.every(w => w >= 0.1 && w <= 0.5)).toBe(true)
    })
  })

  describe('calculateEfficientFrontier', () => {
    it('should generate frontier points', () => {
      const frontier = calculateEfficientFrontier(mockReturns, 50)
      expect(frontier).toHaveLength(50)
      expect(frontier[0].risk).toBeLessThan(frontier[49].risk)
      expect(frontier[0].return).toBeLessThan(frontier[49].return)
    })
  })
})
```

### 2.2 コンポーネントテスト

#### AssetSelector Component Test
```typescript
// tests/unit/components/AssetSelector.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { AssetSelector } from '@/components/forms/AssetSelector'

describe('AssetSelector Component', () => {
  const mockOnChange = jest.fn()
  const mockAssets = [
    { id: 'AAPL', symbol: 'AAPL', name: 'Apple Inc.', type: 'stock' },
    { id: 'GOOGL', symbol: 'GOOGL', name: 'Alphabet Inc.', type: 'stock' },
  ]

  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('should render with placeholder', () => {
    render(
      <AssetSelector
        selectedAssets={[]}
        onAssetsChange={mockOnChange}
        placeholder="Select assets..."
      />
    )
    expect(screen.getByText('Select assets...')).toBeInTheDocument()
  })

  it('should open dropdown on click', async () => {
    render(
      <AssetSelector
        selectedAssets={[]}
        onAssetsChange={mockOnChange}
      />
    )
    
    const button = screen.getByRole('combobox')
    await userEvent.click(button)
    
    expect(screen.getByPlaceholderText(/search/i)).toBeInTheDocument()
  })

  it('should select asset', async () => {
    render(
      <AssetSelector
        selectedAssets={[]}
        onAssetsChange={mockOnChange}
      />
    )
    
    const button = screen.getByRole('combobox')
    await userEvent.click(button)
    
    const searchInput = screen.getByPlaceholderText(/search/i)
    await userEvent.type(searchInput, 'AAPL')
    
    await waitFor(() => {
      const option = screen.getByText('Apple Inc.')
      fireEvent.click(option)
    })
    
    expect(mockOnChange).toHaveBeenCalledWith([mockAssets[0]])
  })

  it('should enforce max assets limit', () => {
    render(
      <AssetSelector
        selectedAssets={[mockAssets[0], mockAssets[1]]}
        onAssetsChange={mockOnChange}
        maxAssets={2}
      />
    )
    
    expect(screen.getByText('2 assets selected')).toBeInTheDocument()
    // Additional assets should be disabled
  })

  it('should remove selected asset', async () => {
    render(
      <AssetSelector
        selectedAssets={[mockAssets[0]]}
        onAssetsChange={mockOnChange}
      />
    )
    
    const removeButton = screen.getByRole('button', { name: /remove/i })
    await userEvent.click(removeButton)
    
    expect(mockOnChange).toHaveBeenCalledWith([])
  })
})
```

### 2.3 Hook Tests

```typescript
// tests/unit/hooks/usePortfolio.test.ts
import { renderHook, act, waitFor } from '@testing-library/react'
import { usePortfolio } from '@/hooks/usePortfolio'
import { apiClient } from '@/lib/api/client'

jest.mock('@/lib/api/client')

describe('usePortfolio Hook', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('should load portfolio data', async () => {
    const mockData = {
      id: '123',
      name: 'Test Portfolio',
      assets: [],
    }
    
    ;(apiClient.get as jest.Mock).mockResolvedValue({
      success: true,
      data: mockData,
    })
    
    const { result } = renderHook(() => usePortfolio('123'))
    
    expect(result.current.isLoading).toBe(true)
    
    await waitFor(() => {
      expect(result.current.isLoading).toBe(false)
      expect(result.current.portfolio).toEqual(mockData)
    })
  })

  it('should handle error state', async () => {
    const mockError = new Error('Failed to load')
    
    ;(apiClient.get as jest.Mock).mockRejectedValue(mockError)
    
    const { result } = renderHook(() => usePortfolio('123'))
    
    await waitFor(() => {
      expect(result.current.isError).toBe(true)
      expect(result.current.error).toBe(mockError)
    })
  })
})
```

## 3. Integration Tests

### 3.1 API Integration Tests

```typescript
// tests/integration/api/portfolio.test.ts
import { createMocks } from 'node-mocks-http'
import handler from '@/app/api/portfolio/optimize/route'
import { prismaMock } from '@/tests/mocks/prisma'

describe('Portfolio Optimization API', () => {
  it('should optimize portfolio with valid data', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: {
        assets: ['AAPL', 'GOOGL', 'MSFT'],
        startDate: '2023-01-01',
        endDate: '2024-01-01',
        optimizationType: 'max_sharpe',
      },
    })

    await handler(req, res)

    expect(res._getStatusCode()).toBe(200)
    
    const data = JSON.parse(res._getData())
    expect(data.success).toBe(true)
    expect(data.data.weights).toHaveLength(3)
    expect(data.data.sharpeRatio).toBeGreaterThan(0)
  })

  it('should validate input parameters', async () => {
    const { req, res } = createMocks({
      method: 'POST',
      body: {
        assets: [], // Invalid: empty array
        startDate: '2024-01-01',
        endDate: '2023-01-01', // Invalid: end before start
      },
    })

    await handler(req, res)

    expect(res._getStatusCode()).toBe(400)
    
    const data = JSON.parse(res._getData())
    expect(data.success).toBe(false)
    expect(data.error.code).toBe('INVALID_REQUEST')
  })

  it('should handle rate limiting', async () => {
    // Simulate multiple requests
    for (let i = 0; i < 101; i++) {
      const { req, res } = createMocks({
        method: 'POST',
        headers: {
          'x-forwarded-for': '192.168.1.1',
        },
        body: {
          assets: ['AAPL'],
          startDate: '2023-01-01',
          endDate: '2024-01-01',
        },
      })

      await handler(req, res)
      
      if (i === 100) {
        expect(res._getStatusCode()).toBe(429)
        const data = JSON.parse(res._getData())
        expect(data.error.code).toBe('RATE_LIMIT_EXCEEDED')
      }
    }
  })
})
```

### 3.2 Database Integration Tests

```typescript
// tests/integration/db/portfolio.test.ts
import { PrismaClient } from '@prisma/client'
import { PortfolioRepository } from '@/lib/repositories/portfolio'

describe('Portfolio Repository Integration', () => {
  let prisma: PrismaClient
  let repository: PortfolioRepository
  let testUserId: string

  beforeAll(async () => {
    prisma = new PrismaClient()
    repository = new PortfolioRepository(prisma)
    
    // Create test user
    const user = await prisma.user.create({
      data: {
        email: 'test@example.com',
        username: 'testuser',
      },
    })
    testUserId = user.id
  })

  afterAll(async () => {
    // Cleanup
    await prisma.user.delete({ where: { id: testUserId } })
    await prisma.$disconnect()
  })

  it('should create portfolio', async () => {
    const portfolio = await repository.create({
      userId: testUserId,
      name: 'Test Portfolio',
      initialInvestment: 10000,
      assets: [
        { symbol: 'AAPL', weight: 0.5 },
        { symbol: 'GOOGL', weight: 0.5 },
      ],
    })

    expect(portfolio.id).toBeDefined()
    expect(portfolio.name).toBe('Test Portfolio')
    expect(portfolio.assets).toHaveLength(2)
  })

  it('should handle concurrent updates', async () => {
    const portfolio = await repository.create({
      userId: testUserId,
      name: 'Concurrent Test',
      initialInvestment: 5000,
    })

    // Simulate concurrent updates
    const updates = Promise.all([
      repository.updateWeight(portfolio.id, 'AAPL', 0.3),
      repository.updateWeight(portfolio.id, 'GOOGL', 0.7),
    ])

    await expect(updates).resolves.not.toThrow()

    const updated = await repository.findById(portfolio.id)
    const totalWeight = updated.assets.reduce((sum, a) => sum + a.weight, 0)
    expect(totalWeight).toBeCloseTo(1.0, 2)
  })
})
```

## 4. End-to-End Tests

### 4.1 Critical User Flows

```typescript
// tests/e2e/portfolio-creation.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Portfolio Creation Flow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/')
  })

  test('should create new portfolio', async ({ page }) => {
    // Navigate to portfolio creation
    await page.click('text=New Portfolio')
    
    // Fill portfolio details
    await page.fill('[name="portfolioName"]', 'My Test Portfolio')
    await page.fill('[name="initialInvestment"]', '10000')
    
    // Select assets
    await page.click('[data-testid="asset-selector"]')
    await page.fill('[placeholder="Search assets..."]', 'AAPL')
    await page.click('text=Apple Inc.')
    
    await page.fill('[placeholder="Search assets..."]', 'GOOGL')
    await page.click('text=Alphabet Inc.')
    
    // Set weights
    await page.fill('[data-testid="weight-AAPL"]', '0.6')
    await page.fill('[data-testid="weight-GOOGL"]', '0.4')
    
    // Create portfolio
    await page.click('button:has-text("Create Portfolio")')
    
    // Verify success
    await expect(page.locator('text=Portfolio created successfully')).toBeVisible()
    await expect(page).toHaveURL(/\/portfolio\/[a-z0-9-]+/)
  })

  test('should validate portfolio inputs', async ({ page }) => {
    await page.click('text=New Portfolio')
    
    // Try to submit empty form
    await page.click('button:has-text("Create Portfolio")')
    
    // Check validation messages
    await expect(page.locator('text=Portfolio name is required')).toBeVisible()
    await expect(page.locator('text=Initial investment must be positive')).toBeVisible()
    
    // Invalid weight total
    await page.fill('[name="portfolioName"]', 'Test')
    await page.fill('[name="initialInvestment"]', '1000')
    
    await page.click('[data-testid="asset-selector"]')
    await page.fill('[placeholder="Search assets..."]', 'AAPL')
    await page.click('text=Apple Inc.')
    
    await page.fill('[data-testid="weight-AAPL"]', '1.5') // Invalid: > 100%
    await page.click('button:has-text("Create Portfolio")')
    
    await expect(page.locator('text=Total weight cannot exceed 100%')).toBeVisible()
  })
})
```

### 4.2 Performance Testing

```typescript
// tests/e2e/performance.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Performance Metrics', () => {
  test('should load homepage within 3 seconds', async ({ page }) => {
    const startTime = Date.now()
    await page.goto('/')
    const loadTime = Date.now() - startTime
    
    expect(loadTime).toBeLessThan(3000)
  })

  test('should render large portfolio efficiently', async ({ page }) => {
    // Navigate to test portfolio with many assets
    await page.goto('/portfolio/test-large-portfolio')
    
    const startTime = Date.now()
    await page.waitForSelector('[data-testid="portfolio-chart"]')
    const renderTime = Date.now() - startTime
    
    expect(renderTime).toBeLessThan(2000)
    
    // Check Core Web Vitals
    const metrics = await page.evaluate(() => {
      return {
        lcp: performance.getEntriesByType('largest-contentful-paint')[0]?.startTime,
        fcp: performance.getEntriesByName('first-contentful-paint')[0]?.startTime,
        cls: 0, // Would need more complex calculation
      }
    })
    
    expect(metrics.lcp).toBeLessThan(2500)
    expect(metrics.fcp).toBeLessThan(1800)
  })
})
```

### 4.3 Mobile Testing

```typescript
// tests/e2e/mobile.spec.ts
import { test, devices, expect } from '@playwright/test'

test.use(devices['iPhone 13'])

test.describe('Mobile Experience', () => {
  test('should be responsive on mobile', async ({ page }) => {
    await page.goto('/')
    
    // Check mobile navigation
    await expect(page.locator('[data-testid="mobile-menu"]')).toBeVisible()
    await expect(page.locator('[data-testid="desktop-menu"]')).not.toBeVisible()
    
    // Open mobile menu
    await page.click('[data-testid="mobile-menu-trigger"]')
    await expect(page.locator('[data-testid="mobile-nav-panel"]')).toBeVisible()
    
    // Navigate to portfolio
    await page.click('text=Portfolios')
    await expect(page).toHaveURL('/portfolios')
  })

  test('should handle touch gestures', async ({ page }) => {
    await page.goto('/portfolio/test-portfolio')
    
    const chart = page.locator('[data-testid="portfolio-chart"]')
    
    // Simulate pinch zoom
    await chart.dispatchEvent('touchstart', {
      touches: [
        { clientX: 100, clientY: 100 },
        { clientX: 200, clientY: 200 },
      ],
    })
    
    await chart.dispatchEvent('touchmove', {
      touches: [
        { clientX: 50, clientY: 50 },
        { clientX: 250, clientY: 250 },
      ],
    })
    
    await chart.dispatchEvent('touchend')
    
    // Verify zoom applied
    const transform = await chart.evaluate((el) => {
      return window.getComputedStyle(el).transform
    })
    expect(transform).not.toBe('none')
  })
})
```

## 5. Load Testing

### 5.1 K6 Load Test Script

```javascript
// tests/load/portfolio-api.js
import http from 'k6/http'
import { check, sleep } from 'k6'
import { Rate } from 'k6/metrics'

const errorRate = new Rate('errors')

export const options = {
  stages: [
    { duration: '2m', target: 100 }, // Ramp up
    { duration: '5m', target: 100 }, // Stay at 100 users
    { duration: '2m', target: 200 }, // Ramp up
    { duration: '5m', target: 200 }, // Stay at 200 users
    { duration: '2m', target: 0 },   // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% of requests under 500ms
    errors: ['rate<0.01'],             // Error rate under 1%
  },
}

export default function () {
  // Test portfolio optimization endpoint
  const payload = JSON.stringify({
    assets: ['AAPL', 'GOOGL', 'MSFT', 'AMZN'],
    startDate: '2023-01-01',
    endDate: '2024-01-01',
    optimizationType: 'max_sharpe',
  })

  const params = {
    headers: {
      'Content-Type': 'application/json',
    },
  }

  const res = http.post(
    'https://api.example.com/api/portfolio/optimize',
    payload,
    params
  )

  const success = check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
    'has optimization result': (r) => {
      const body = JSON.parse(r.body)
      return body.success && body.data.weights
    },
  })

  errorRate.add(!success)
  sleep(1)
}
```

## 6. Security Testing

### 6.1 OWASP Security Tests

```typescript
// tests/security/injection.test.ts
import { test, expect } from '@playwright/test'

test.describe('SQL Injection Prevention', () => {
  test('should prevent SQL injection in search', async ({ page }) => {
    await page.goto('/')
    
    const maliciousInput = "'; DROP TABLE users; --"
    await page.fill('[data-testid="search-input"]', maliciousInput)
    await page.press('[data-testid="search-input"]', 'Enter')
    
    // Should handle gracefully without error
    await expect(page.locator('text=No results found')).toBeVisible()
    
    // Verify no server error
    const response = await page.waitForResponse(
      (response) => response.url().includes('/api/assets/search')
    )
    expect(response.status()).not.toBe(500)
  })
})

test.describe('XSS Prevention', () => {
  test('should sanitize user input', async ({ page }) => {
    await page.goto('/portfolio/new')
    
    const xssPayload = '<script>alert("XSS")</script>'
    await page.fill('[name="portfolioName"]', xssPayload)
    await page.click('button:has-text("Create")')
    
    // Check that script is not executed
    const alertFired = await page.evaluate(() => {
      let alertCalled = false
      const originalAlert = window.alert
      window.alert = () => {
        alertCalled = true
      }
      // Wait a bit to see if alert fires
      return new Promise((resolve) => {
        setTimeout(() => {
          window.alert = originalAlert
          resolve(alertCalled)
        }, 1000)
      })
    })
    
    expect(alertFired).toBe(false)
  })
})
```

## 7. Accessibility Testing

```typescript
// tests/a11y/accessibility.spec.ts
import { test, expect } from '@playwright/test'
import { injectAxe, checkA11y } from 'axe-playwright'

test.describe('Accessibility', () => {
  test('should not have any automatically detectable accessibility issues', async ({ page }) => {
    await page.goto('/')
    await injectAxe(page)
    await checkA11y(page, null, {
      detailedReport: true,
      detailedReportOptions: {
        html: true,
      },
    })
  })

  test('should be keyboard navigable', async ({ page }) => {
    await page.goto('/')
    
    // Tab through interactive elements
    await page.keyboard.press('Tab')
    const firstFocused = await page.evaluate(() => document.activeElement?.tagName)
    expect(['A', 'BUTTON', 'INPUT']).toContain(firstFocused)
    
    // Navigate with arrow keys in dropdown
    await page.click('[data-testid="asset-selector"]')
    await page.keyboard.press('ArrowDown')
    await page.keyboard.press('Enter')
    
    // Should select item
    await expect(page.locator('[data-testid="selected-assets"]')).not.toBeEmpty()
  })

  test('should have proper ARIA labels', async ({ page }) => {
    await page.goto('/')
    
    // Check main navigation
    const nav = page.locator('nav[aria-label="Main navigation"]')
    await expect(nav).toBeVisible()
    
    // Check form inputs
    const searchInput = page.locator('input[aria-label="Search assets"]')
    await expect(searchInput).toBeVisible()
    
    // Check buttons
    const createButton = page.locator('button[aria-label="Create new portfolio"]')
    await expect(createButton).toBeVisible()
  })
})
```

## 8. CI/CD Pipeline Configuration

### 8.1 GitHub Actions Workflow

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
        with:
          version: 8
      - uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'pnpm'
      
      - run: pnpm install
      - run: pnpm test:unit
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
      - uses: actions/setup-node@v3
      
      - run: pnpm install
      - run: pnpm prisma migrate deploy
      - run: pnpm test:integration

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
      - uses: actions/setup-node@v3
      
      - run: pnpm install
      - run: pnpm build
      - run: npx playwright install --with-deps
      - run: pnpm test:e2e
      
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30
```

---
*最終更新日: 2024年12月*
*バージョン: 1.0.0*
