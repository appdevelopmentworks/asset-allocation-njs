# トラブルシューティングガイド - Asset Allocation Tool

## 1. よくある問題と解決方法

### 1.1 ビルドエラー

#### Module not found エラー
**症状**: 
```bash
Module not found: Can't resolve '@/components/...'
```

**原因**: TypeScriptパスエイリアスの設定ミス

**解決方法**:
```json
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/*": ["./src/*"],
      "@/components/*": ["./src/components/*"],
      "@/lib/*": ["./src/lib/*"]
    }
  }
}
```

#### Out of Memory エラー
**症状**:
```bash
FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory
```

**解決方法**:
```bash
# メモリ制限を増やす
NODE_OPTIONS="--max-old-space-size=4096" pnpm build

# または package.json に追加
{
  "scripts": {
    "build": "NODE_OPTIONS='--max-old-space-size=4096' next build"
  }
}
```

### 1.2 ランタイムエラー

#### Hydration Mismatch
**症状**:
```
Error: Hydration failed because the initial UI does not match what was rendered on the server
```

**原因と解決**:
```typescript
// ❌ Bad: Date/Time causing mismatch
function Component() {
  return <div>{new Date().toLocaleString()}</div>
}

// ✅ Good: Use useEffect or dynamic import
function Component() {
  const [date, setDate] = useState<string>()
  
  useEffect(() => {
    setDate(new Date().toLocaleString())
  }, [])
  
  return <div>{date || 'Loading...'}</div>
}

// Or use dynamic import with ssr: false
const ClientOnlyComponent = dynamic(
  () => import('./ClientOnlyComponent'),
  { ssr: false }
)
```

#### CORS エラー
**症状**:
```
Access to fetch at 'https://api.example.com' from origin 'http://localhost:3000' has been blocked by CORS policy
```

**解決方法**:
```typescript
// app/api/proxy/[...path]/route.ts
export async function GET(
  req: NextRequest,
  { params }: { params: { path: string[] } }
) {
  const path = params.path.join('/')
  const response = await fetch(`https://api.example.com/${path}`, {
    headers: {
      'Authorization': `Bearer ${process.env.API_KEY}`,
    },
  })
  
  const data = await response.json()
  
  return NextResponse.json(data, {
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  })
}
```

### 1.3 データベースエラー

#### Connection Pool Exhausted
**症状**:
```
Error: Connection pool exhausted
```

**解決方法**:
```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

// Singleton pattern to prevent multiple instances
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? 
  new PrismaClient({
    datasources: {
      db: {
        url: process.env.DATABASE_URL + '?connection_limit=5&pool_timeout=20'
      }
    }
  })

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}

// Clean up connections on hot reload
if (process.env.NODE_ENV === 'development') {
  process.on('beforeExit', async () => {
    await prisma.$disconnect()
  })
}
```

#### Migration Issues
**症状**:
```
Error: P3009: migrate found failed migrations
```

**解決方法**:
```bash
# Reset database (開発環境のみ)
pnpm prisma migrate reset

# 本番環境での修復
pnpm prisma migrate resolve --applied "20240101000000_migration_name"

# データベースの状態を確認
pnpm prisma migrate status
```

## 2. パフォーマンス問題

### 2.1 遅いページロード

#### 診断スクリプト
```typescript
// scripts/diagnose-performance.ts
import lighthouse from 'lighthouse'
import * as chromeLauncher from 'chrome-launcher'

async function runLighthouse(url: string) {
  const chrome = await chromeLauncher.launch({ chromeFlags: ['--headless'] })
  const options = {
    logLevel: 'info',
    output: 'html',
    port: chrome.port,
  }
  
  const runnerResult = await lighthouse(url, options)
  
  console.log('Performance score:', runnerResult.lhr.categories.performance.score)
  console.log('LCP:', runnerResult.lhr.audits['largest-contentful-paint'].displayValue)
  console.log('FID:', runnerResult.lhr.audits['max-potential-fid'].displayValue)
  console.log('CLS:', runnerResult.lhr.audits['cumulative-layout-shift'].displayValue)
  
  await chrome.kill()
}

runLighthouse('http://localhost:3000')
```

#### 最適化チェックリスト
```typescript
// components/PerformanceDebugger.tsx
'use client'

import { useEffect } from 'react'

export function PerformanceDebugger() {
  useEffect(() => {
    // Log performance metrics
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        console.log(`${entry.name}: ${entry.startTime}ms`)
        
        // Report slow components
        if (entry.duration > 100) {
          console.warn(`Slow component: ${entry.name} took ${entry.duration}ms`)
        }
      }
    })
    
    observer.observe({ entryTypes: ['measure', 'navigation'] })
    
    // Measure initial load
    if (performance.getEntriesByType('navigation').length > 0) {
      const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
      console.log('Page load time:', navigation.loadEventEnd - navigation.fetchStart)
    }
  }, [])
  
  return null
}
```

### 2.2 メモリリーク

#### 検出ツール
```typescript
// hooks/useMemoryLeakDetector.ts
import { useEffect, useRef } from 'react'

export function useMemoryLeakDetector(componentName: string) {
  const renderCount = useRef(0)
  const instancesRef = useRef(new Set())
  
  useEffect(() => {
    renderCount.current++
    const instance = Symbol(`${componentName}-${renderCount.current}`)
    instancesRef.current.add(instance)
    
    // Check for memory leaks
    if (instancesRef.current.size > 10) {
      console.warn(
        `Potential memory leak in ${componentName}: ${instancesRef.current.size} instances`
      )
    }
    
    return () => {
      instancesRef.current.delete(instance)
    }
  }, [componentName])
  
  // Monitor memory usage
  useEffect(() => {
    if ('memory' in performance) {
      const checkMemory = () => {
        const memory = (performance as any).memory
        const usedMB = Math.round(memory.usedJSHeapSize / 1048576)
        const totalMB = Math.round(memory.totalJSHeapSize / 1048576)
        
        if (usedMB > totalMB * 0.9) {
          console.warn(`High memory usage: ${usedMB}MB / ${totalMB}MB`)
        }
      }
      
      const interval = setInterval(checkMemory, 5000)
      return () => clearInterval(interval)
    }
  }, [])
}
```

## 3. 認証・認可の問題

### 3.1 セッション関連

#### セッションが保持されない
**症状**: ログイン後すぐにログアウトされる

**解決方法**:
```typescript
// lib/auth/session.ts
import { cookies } from 'next/headers'

export async function createSession(userId: string) {
  const cookieStore = cookies()
  
  // Set secure cookie options
  cookieStore.set('session', sessionToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24 * 7, // 1 week
    path: '/',
  })
}

// middleware.ts
export function middleware(request: NextRequest) {
  const session = request.cookies.get('session')
  
  if (!session) {
    return NextResponse.redirect(new URL('/login', request.url))
  }
  
  // Refresh session
  const response = NextResponse.next()
  response.cookies.set('session', session.value, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24 * 7,
    path: '/',
  })
  
  return response
}
```

### 3.2 JWT トークン問題

```typescript
// lib/auth/jwt-debug.ts
import jwt from 'jsonwebtoken'

export function debugJWT(token: string) {
  try {
    // Decode without verification
    const decoded = jwt.decode(token, { complete: true })
    console.log('Header:', decoded?.header)
    console.log('Payload:', decoded?.payload)
    
    // Check expiration
    if (decoded?.payload?.exp) {
      const expirationDate = new Date(decoded.payload.exp * 1000)
      const now = new Date()
      
      if (expirationDate < now) {
        console.error('Token expired at:', expirationDate)
      } else {
        console.log('Token valid until:', expirationDate)
      }
    }
    
    // Verify signature
    try {
      const verified = jwt.verify(token, process.env.JWT_SECRET!)
      console.log('Signature valid')
    } catch (error) {
      console.error('Signature invalid:', error.message)
    }
  } catch (error) {
    console.error('Failed to decode token:', error)
  }
}
```

## 4. API関連の問題

### 4.1 Rate Limiting Issues

```typescript
// lib/rate-limit-debug.ts
export async function debugRateLimit(identifier: string) {
  const redis = new Redis({
    url: process.env.UPSTASH_REDIS_REST_URL!,
    token: process.env.UPSTASH_REDIS_REST_TOKEN!,
  })
  
  // Check current rate limit status
  const key = `ratelimit:${identifier}`
  const data = await redis.get(key)
  
  console.log('Rate limit data:', data)
  
  // Reset rate limit (development only)
  if (process.env.NODE_ENV === 'development') {
    await redis.del(key)
    console.log('Rate limit reset for:', identifier)
  }
}

// API Route with detailed error
export async function POST(req: Request) {
  const ip = req.headers.get('x-forwarded-for') ?? 'unknown'
  const { success, limit, reset, remaining } = await ratelimit.limit(ip)
  
  if (!success) {
    const retryAfter = Math.ceil((reset - Date.now()) / 1000)
    
    return NextResponse.json(
      {
        error: 'Rate limit exceeded',
        limit,
        remaining,
        reset: new Date(reset).toISOString(),
        retryAfter: `${retryAfter} seconds`,
      },
      {
        status: 429,
        headers: {
          'Retry-After': retryAfter.toString(),
          'X-RateLimit-Limit': limit.toString(),
          'X-RateLimit-Remaining': remaining.toString(),
          'X-RateLimit-Reset': new Date(reset).toISOString(),
        },
      }
    )
  }
}
```

### 4.2 タイムアウト問題

```typescript
// lib/api/timeout-handler.ts
export async function fetchWithTimeout(
  url: string,
  options: RequestInit = {},
  timeout: number = 5000
): Promise<Response> {
  const controller = new AbortController()
  const timeoutId = setTimeout(() => controller.abort(), timeout)
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    })
    
    clearTimeout(timeoutId)
    return response
  } catch (error) {
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeout}ms`)
    }
    throw error
  }
}

// Retry mechanism
export async function fetchWithRetry(
  url: string,
  options: RequestInit = {},
  maxRetries: number = 3
): Promise<Response> {
  let lastError: Error
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetchWithTimeout(url, options)
      
      if (response.ok) {
        return response
      }
      
      // Retry on 5xx errors
      if (response.status >= 500) {
        lastError = new Error(`Server error: ${response.status}`)
        await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)))
        continue
      }
      
      return response
    } catch (error) {
      lastError = error as Error
      console.error(`Attempt ${i + 1} failed:`, error)
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)))
    }
  }
  
  throw lastError!
}
```

## 5. デバッグツール

### 5.1 Debug パネル

```typescript
// components/DebugPanel.tsx
'use client'

import { useState, useEffect } from 'react'

export function DebugPanel() {
  const [isOpen, setIsOpen] = useState(false)
  const [metrics, setMetrics] = useState<any>({})
  
  useEffect(() => {
    if (process.env.NODE_ENV !== 'development') return
    
    // Keyboard shortcut: Ctrl+Shift+D
    const handleKeyPress = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'D') {
        setIsOpen(prev => !prev)
      }
    }
    
    window.addEventListener('keydown', handleKeyPress)
    return () => window.removeEventListener('keydown', handleKeyPress)
  }, [])
  
  useEffect(() => {
    const interval = setInterval(() => {
      setMetrics({
        memory: (performance as any).memory
          ? `${Math.round((performance as any).memory.usedJSHeapSize / 1048576)}MB`
          : 'N/A',
        renderCount: (window as any).__RENDER_COUNT__ || 0,
        apiCalls: (window as any).__API_CALLS__ || 0,
        cacheHits: (window as any).__CACHE_HITS__ || 0,
        errors: (window as any).__ERRORS__ || [],
      })
    }, 1000)
    
    return () => clearInterval(interval)
  }, [])
  
  if (!isOpen || process.env.NODE_ENV !== 'development') return null
  
  return (
    <div className="fixed bottom-0 right-0 bg-black text-white p-4 max-w-md z-50">
      <div className="flex justify-between mb-2">
        <h3 className="font-bold">Debug Panel</h3>
        <button onClick={() => setIsOpen(false)}>✕</button>
      </div>
      
      <div className="space-y-1 text-sm">
        <div>Memory: {metrics.memory}</div>
        <div>Renders: {metrics.renderCount}</div>
        <div>API Calls: {metrics.apiCalls}</div>
        <div>Cache Hits: {metrics.cacheHits}</div>
        
        {metrics.errors?.length > 0 && (
          <div className="mt-2">
            <div className="font-bold">Recent Errors:</div>
            {metrics.errors.slice(-5).map((error, i) => (
              <div key={i} className="text-red-400 text-xs">
                {error.message}
              </div>
            ))}
          </div>
        )}
      </div>
      
      <div className="mt-2 space-x-2">
        <button
          onClick={() => {
            localStorage.clear()
            sessionStorage.clear()
            window.location.reload()
          }}
          className="bg-red-600 px-2 py-1 text-xs"
        >
          Clear Storage
        </button>
        
        <button
          onClick={() => {
            (window as any).__CACHE_HITS__ = 0
            (window as any).__API_CALLS__ = 0
            (window as any).__RENDER_COUNT__ = 0
            (window as any).__ERRORS__ = []
          }}
          className="bg-blue-600 px-2 py-1 text-xs"
        >
          Reset Metrics
        </button>
      </div>
    </div>
  )
}
```

### 5.2 ログユーティリティ

```typescript
// lib/logger.ts
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
}

class Logger {
  private level: LogLevel
  private isDevelopment: boolean
  
  constructor() {
    this.isDevelopment = process.env.NODE_ENV === 'development'
    this.level = this.isDevelopment ? LogLevel.DEBUG : LogLevel.ERROR
  }
  
  private formatMessage(level: string, message: string, data?: any): string {
    const timestamp = new Date().toISOString()
    const formatted = `[${timestamp}] [${level}] ${message}`
    
    if (data) {
      return `${formatted}\n${JSON.stringify(data, null, 2)}`
    }
    
    return formatted
  }
  
  debug(message: string, data?: any) {
    if (this.level <= LogLevel.DEBUG) {
      console.log(this.formatMessage('DEBUG', message, data))
    }
  }
  
  info(message: string, data?: any) {
    if (this.level <= LogLevel.INFO) {
      console.info(this.formatMessage('INFO', message, data))
    }
  }
  
  warn(message: string, data?: any) {
    if (this.level <= LogLevel.WARN) {
      console.warn(this.formatMessage('WARN', message, data))
    }
    
    // Track warnings
    if (typeof window !== 'undefined') {
      (window as any).__WARNINGS__ = (window as any).__WARNINGS__ || []
      (window as any).__WARNINGS__.push({ message, data, timestamp: Date.now() })
    }
  }
  
  error(message: string, error?: any) {
    console.error(this.formatMessage('ERROR', message, error))
    
    // Track errors
    if (typeof window !== 'undefined') {
      (window as any).__ERRORS__ = (window as any).__ERRORS__ || []
      (window as any).__ERRORS__.push({ 
        message, 
        error: error?.message || error,
        stack: error?.stack,
        timestamp: Date.now() 
      })
    }
    
    // Report to error tracking service
    if (!this.isDevelopment && typeof window !== 'undefined') {
      // Sentry, LogRocket, etc.
      if ((window as any).Sentry) {
        (window as any).Sentry.captureException(error || new Error(message))
      }
    }
  }
  
  // Group related logs
  group(label: string, fn: () => void) {
    if (this.isDevelopment) {
      console.group(label)
      fn()
      console.groupEnd()
    } else {
      fn()
    }
  }
  
  // Time operations
  time(label: string): () => void {
    const start = performance.now()
    
    return () => {
      const duration = performance.now() - start
      this.debug(`${label} took ${duration.toFixed(2)}ms`)
      
      if (duration > 1000) {
        this.warn(`Slow operation: ${label}`, { duration })
      }
    }
  }
}

export const logger = new Logger()
```

## 6. 環境別の設定

### 6.1 環境変数の検証

```typescript
// scripts/validate-env.ts
import { z } from 'zod'

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'test', 'production']),
  
  // Database
  DATABASE_URL: z.string().url(),
  DIRECT_URL: z.string().url().optional(),
  
  // Supabase
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1),
  
  // Redis
  UPSTASH_REDIS_REST_URL: z.string().url(),
  UPSTASH_REDIS_REST_TOKEN: z.string().min(1),
  
  // External APIs
  YAHOO_FINANCE_API_KEY: z.string().optional(),
  
  // Auth
  JWT_SECRET: z.string().min(32),
  
  // Monitoring
  NEXT_PUBLIC_SENTRY_DSN: z.string().url().optional(),
})

export function validateEnv() {
  try {
    const env = envSchema.parse(process.env)
    console.log('✅ Environment variables validated')
    return env
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error('❌ Invalid environment variables:')
      error.errors.forEach(err => {
        console.error(`  ${err.path}: ${err.message}`)
      })
      process.exit(1)
    }
    throw error
  }
}

// Run if executed directly
if (require.main === module) {
  validateEnv()
}
```

### 6.2 環境別の設定ファイル

```typescript
// lib/config/index.ts
interface Config {
  api: {
    baseUrl: string
    timeout: number
    retryAttempts: number
  }
  cache: {
    ttl: number
    maxSize: number
  }
  features: {
    enableBeta: boolean
    enableAnalytics: boolean
    enableDebugPanel: boolean
  }
  limits: {
    maxPortfolios: number
    maxAssetsPerPortfolio: number
    maxApiRequestsPerMinute: number
  }
}

const configs: Record<string, Config> = {
  development: {
    api: {
      baseUrl: 'http://localhost:3000',
      timeout: 10000,
      retryAttempts: 1,
    },
    cache: {
      ttl: 60,
      maxSize: 100,
    },
    features: {
      enableBeta: true,
      enableAnalytics: false,
      enableDebugPanel: true,
    },
    limits: {
      maxPortfolios: 100,
      maxAssetsPerPortfolio: 50,
      maxApiRequestsPerMinute: 1000,
    },
  },
  production: {
    api: {
      baseUrl: 'https://api.assetallocation.com',
      timeout: 5000,
      retryAttempts: 3,
    },
    cache: {
      ttl: 3600,
      maxSize: 1000,
    },
    features: {
      enableBeta: false,
      enableAnalytics: true,
      enableDebugPanel: false,
    },
    limits: {
      maxPortfolios: 10,
      maxAssetsPerPortfolio: 20,
      maxApiRequestsPerMinute: 100,
    },
  },
}

export const config = configs[process.env.NODE_ENV] || configs.development
```

## 7. 緊急時の対応

### 7.1 ホットフィックス手順

```bash
#!/bin/bash
# scripts/hotfix.sh

# 1. Create hotfix branch
git checkout main
git pull origin main
git checkout -b hotfix/critical-fix

# 2. Apply fix
echo "Apply your fix now..."

# 3. Test locally
pnpm test
pnpm build

# 4. Deploy to staging
git push origin hotfix/critical-fix
vercel deploy --prod --env staging

# 5. Test on staging
echo "Test on staging: https://staging.assetallocation.com"

# 6. Merge to main
git checkout main
git merge hotfix/critical-fix
git push origin main

# 7. Deploy to production
vercel deploy --prod

# 8. Verify production
curl -I https://app.assetallocation.com

# 9. Tag release
git tag -a hotfix-$(date +%Y%m%d-%H%M%S) -m "Hotfix deployed"
git push origin --tags
```

### 7.2 ロールバック手順

```bash
#!/bin/bash
# scripts/rollback.sh

# 1. Find last stable deployment
vercel list

# 2. Get deployment URL
read -p "Enter stable deployment URL: " DEPLOYMENT_URL

# 3. Promote to production
vercel promote $DEPLOYMENT_URL

# 4. Verify
curl -I https://app.assetallocation.com

# 5. Revert database if needed
echo "Run database rollback if needed:"
echo "pnpm prisma migrate resolve --rolled-back"
```

---
*最終更新日: 2024年12月*
*バージョン: 1.0.0*
