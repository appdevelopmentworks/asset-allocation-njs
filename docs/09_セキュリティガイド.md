# セキュリティガイド - Asset Allocation Tool

## 1. セキュリティアーキテクチャ

### 1.1 多層防御戦略
```
┌────────────────────────────────────────┐
│           WAF (Cloudflare)             │
│     DDoS Protection, Rate Limiting     │
└────────────────────────────────────────┘
                    │
┌────────────────────────────────────────┐
│         Edge Middleware (Vercel)       │
│   Authentication, Authorization, CSP   │
└────────────────────────────────────────┘
                    │
┌────────────────────────────────────────┐
│        Application Layer (Next.js)     │
│   Input Validation, CSRF Protection    │
└────────────────────────────────────────┘
                    │
┌────────────────────────────────────────┐
│         Database (Supabase)            │
│     RLS, Encryption, Audit Logs       │
└────────────────────────────────────────┘
```

## 2. 認証・認可

### 2.1 認証フロー実装

```typescript
// lib/auth/auth.ts
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import { cache } from 'react'

export const getSession = cache(async () => {
  const cookieStore = cookies()
  
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
      },
    }
  )
  
  const { data: { session }, error } = await supabase.auth.getSession()
  
  if (error) {
    console.error('Session error:', error)
    return null
  }
  
  return session
})

export const requireAuth = async () => {
  const session = await getSession()
  
  if (!session) {
    throw new Error('Unauthorized')
  }
  
  return session
}
```

### 2.2 認可ミドルウェア

```typescript
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'

const PUBLIC_ROUTES = ['/', '/login', '/signup', '/api/health']
const ADMIN_ROUTES = ['/admin']

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })
  
  const {
    data: { session },
  } = await supabase.auth.getSession()
  
  const isPublicRoute = PUBLIC_ROUTES.includes(req.nextUrl.pathname)
  const isAdminRoute = ADMIN_ROUTES.some(route => 
    req.nextUrl.pathname.startsWith(route)
  )
  
  // Redirect if not authenticated and accessing protected route
  if (!session && !isPublicRoute) {
    return NextResponse.redirect(new URL('/login', req.url))
  }
  
  // Check admin authorization
  if (isAdminRoute && session) {
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', session.user.id)
      .single()
    
    if (profile?.role !== 'admin') {
      return NextResponse.redirect(new URL('/unauthorized', req.url))
    }
  }
  
  return res
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}
```

## 3. 入力検証とサニタイゼーション

### 3.1 Zodスキーマによる検証

```typescript
// lib/validations/portfolio.ts
import { z } from 'zod'

// SQL Injection対策
const SafeStringSchema = z.string().regex(
  /^[a-zA-Z0-9\s\-_.]+$/,
  'Invalid characters detected'
)

// XSS対策
const sanitizeHtml = (input: string) => {
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;')
}

export const PortfolioSchema = z.object({
  name: SafeStringSchema
    .min(1, 'Name is required')
    .max(100, 'Name too long')
    .transform(sanitizeHtml),
  
  description: z.string()
    .max(500)
    .transform(sanitizeHtml)
    .optional(),
  
  initialInvestment: z.number()
    .positive('Must be positive')
    .max(1000000000, 'Amount too large'),
  
  assets: z.array(z.object({
    symbol: z.string()
      .regex(/^[A-Z0-9\-]{1,10}$/, 'Invalid symbol format'),
    weight: z.number()
      .min(0, 'Weight must be non-negative')
      .max(1, 'Weight cannot exceed 100%'),
  }))
  .min(1, 'At least one asset required')
  .max(50, 'Too many assets')
  .refine(
    (assets) => {
      const totalWeight = assets.reduce((sum, a) => sum + a.weight, 0)
      return Math.abs(totalWeight - 1) < 0.001
    },
    'Total weight must equal 100%'
  ),
})

// API Route使用例
export async function POST(req: Request) {
  try {
    const body = await req.json()
    const validated = PortfolioSchema.parse(body)
    
    // Validated data is safe to use
    return createPortfolio(validated)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      )
    }
    throw error
  }
}
```

### 3.2 SQLインジェクション対策

```typescript
// lib/db/queries.ts
import { sql } from '@vercel/postgres'

// パラメータ化クエリ（推奨）
export async function getPortfolioById(
  userId: string,
  portfolioId: string
) {
  const result = await sql`
    SELECT * FROM portfolios
    WHERE user_id = ${userId}
    AND id = ${portfolioId}
    AND deleted_at IS NULL
  `
  return result.rows[0]
}

// Prisma使用（推奨）
import { prisma } from '@/lib/prisma'

export async function getPortfolioByIdPrisma(
  userId: string,
  portfolioId: string
) {
  return await prisma.portfolio.findFirst({
    where: {
      id: portfolioId,
      userId,
      deletedAt: null,
    },
  })
}

// 危険な例（使用禁止）
// ❌ Never do this:
// const query = `SELECT * FROM portfolios WHERE id = '${portfolioId}'`
```

## 4. CSRF対策

### 4.1 CSRFトークン実装

```typescript
// lib/csrf.ts
import crypto from 'crypto'
import { cookies } from 'next/headers'

export function generateCsrfToken(): string {
  return crypto.randomBytes(32).toString('hex')
}

export async function validateCsrfToken(token: string): Promise<boolean> {
  const cookieStore = cookies()
  const storedToken = cookieStore.get('csrf-token')?.value
  
  if (!storedToken || !token) {
    return false
  }
  
  // タイミング攻撃対策
  return crypto.timingSafeEqual(
    Buffer.from(storedToken),
    Buffer.from(token)
  )
}

// API Route Protection
export async function protectedApiRoute(req: Request) {
  const token = req.headers.get('X-CSRF-Token')
  
  if (!token || !(await validateCsrfToken(token))) {
    return NextResponse.json(
      { error: 'Invalid CSRF token' },
      { status: 403 }
    )
  }
  
  // Process request
}
```

### 4.2 Double Submit Cookie Pattern

```typescript
// components/CsrfProtectedForm.tsx
'use client'

import { useEffect, useState } from 'react'

export function CsrfProtectedForm({ children, onSubmit }) {
  const [csrfToken, setCsrfToken] = useState('')
  
  useEffect(() => {
    // Get CSRF token from server
    fetch('/api/csrf')
      .then(res => res.json())
      .then(data => setCsrfToken(data.token))
  }, [])
  
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault()
    
    const formData = new FormData(e.currentTarget)
    
    await fetch('/api/portfolio', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken,
      },
      body: JSON.stringify(Object.fromEntries(formData)),
    })
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input type="hidden" name="_csrf" value={csrfToken} />
      {children}
    </form>
  )
}
```

## 5. XSS対策

### 5.1 Content Security Policy

```typescript
// app/layout.tsx
export const metadata: Metadata = {
  other: {
    'Content-Security-Policy': 
      "default-src 'self'; " +
      "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://vercel.live; " +
      "style-src 'self' 'unsafe-inline'; " +
      "img-src 'self' data: https:; " +
      "font-src 'self' data:; " +
      "connect-src 'self' https://*.supabase.co https://*.yahoo.com; " +
      "frame-ancestors 'none'; " +
      "base-uri 'self'; " +
      "form-action 'self';",
  },
}
```

### 5.2 安全なHTML表示

```typescript
// components/SafeHtml.tsx
import DOMPurify from 'isomorphic-dompurify'

interface SafeHtmlProps {
  html: string
  allowedTags?: string[]
}

export function SafeHtml({ 
  html, 
  allowedTags = ['p', 'br', 'strong', 'em'] 
}: SafeHtmlProps) {
  const clean = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: allowedTags,
    ALLOWED_ATTR: [],
  })
  
  return (
    <div 
      dangerouslySetInnerHTML={{ __html: clean }}
      className="prose"
    />
  )
}

// 使用例
<SafeHtml html={userGeneratedContent} />
```

## 6. APIセキュリティ

### 6.1 Rate Limiting実装

```typescript
// lib/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
})

// Create different rate limiters for different endpoints
export const rateLimiters = {
  api: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(100, '1 m'),
    analytics: true,
  }),
  
  auth: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(5, '15 m'),
    analytics: true,
  }),
  
  expensive: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(10, '1 h'),
    analytics: true,
  }),
}

// API Route Example
export async function POST(req: Request) {
  const ip = req.headers.get('x-forwarded-for') ?? 'unknown'
  
  const { success, limit, reset, remaining } = await rateLimiters.api.limit(
    `api_${ip}`
  )
  
  if (!success) {
    return new Response('Too Many Requests', {
      status: 429,
      headers: {
        'X-RateLimit-Limit': limit.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': new Date(reset).toISOString(),
        'Retry-After': Math.floor((reset - Date.now()) / 1000).toString(),
      },
    })
  }
  
  // Process request
}
```

### 6.2 API Key管理

```typescript
// lib/api-keys.ts
import crypto from 'crypto'
import { prisma } from '@/lib/prisma'

export async function generateApiKey(userId: string): Promise<string> {
  const key = `sk_${crypto.randomBytes(32).toString('hex')}`
  const hashedKey = crypto
    .createHash('sha256')
    .update(key)
    .digest('hex')
  
  await prisma.apiKey.create({
    data: {
      userId,
      key: hashedKey,
      prefix: key.substring(0, 7),
      expiresAt: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days
    },
  })
  
  return key // Return only once to user
}

export async function validateApiKey(key: string): Promise<boolean> {
  const hashedKey = crypto
    .createHash('sha256')
    .update(key)
    .digest('hex')
  
  const apiKey = await prisma.apiKey.findUnique({
    where: { key: hashedKey },
    include: { user: true },
  })
  
  if (!apiKey || apiKey.expiresAt < new Date()) {
    return false
  }
  
  // Update last used
  await prisma.apiKey.update({
    where: { id: apiKey.id },
    data: { lastUsed: new Date() },
  })
  
  return true
}
```

## 7. データ暗号化

### 7.1 暗号化ユーティリティ

```typescript
// lib/crypto.ts
import crypto from 'crypto'

const algorithm = 'aes-256-gcm'
const secretKey = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex')

export function encrypt(text: string): string {
  const iv = crypto.randomBytes(16)
  const cipher = crypto.createCipheriv(algorithm, secretKey, iv)
  
  let encrypted = cipher.update(text, 'utf8', 'hex')
  encrypted += cipher.final('hex')
  
  const authTag = cipher.getAuthTag()
  
  return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted
}

export function decrypt(encryptedData: string): string {
  const parts = encryptedData.split(':')
  const iv = Buffer.from(parts[0], 'hex')
  const authTag = Buffer.from(parts[1], 'hex')
  const encrypted = parts[2]
  
  const decipher = crypto.createDecipheriv(algorithm, secretKey, iv)
  decipher.setAuthTag(authTag)
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8')
  decrypted += decipher.final('utf8')
  
  return decrypted
}

// 使用例
const sensitiveData = 'user-api-key'
const encrypted = encrypt(sensitiveData)
const decrypted = decrypt(encrypted)
```

### 7.2 フィールドレベル暗号化

```typescript
// prisma/middleware.ts
import { PrismaClient } from '@prisma/client'
import { encrypt, decrypt } from '@/lib/crypto'

const prisma = new PrismaClient()

prisma.$use(async (params, next) => {
  // Encrypt sensitive fields before saving
  if (params.model === 'User' && params.action === 'create') {
    if (params.args.data.ssn) {
      params.args.data.ssn = encrypt(params.args.data.ssn)
    }
  }
  
  const result = await next(params)
  
  // Decrypt sensitive fields after reading
  if (params.model === 'User' && params.action === 'findUnique') {
    if (result?.ssn) {
      result.ssn = decrypt(result.ssn)
    }
  }
  
  return result
})

export { prisma }
```

## 8. セキュリティヘッダー

### 8.1 包括的なセキュリティヘッダー設定

```typescript
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const response = NextResponse.next()
  
  // Security Headers
  const headers = {
    // XSS Protection
    'X-XSS-Protection': '1; mode=block',
    
    // Prevent MIME type sniffing
    'X-Content-Type-Options': 'nosniff',
    
    // Referrer Policy
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    
    // Frame Options (Clickjacking protection)
    'X-Frame-Options': 'DENY',
    
    // HSTS
    'Strict-Transport-Security': 
      'max-age=63072000; includeSubDomains; preload',
    
    // Permissions Policy
    'Permissions-Policy': 
      'camera=(), microphone=(), geolocation=(), interest-cohort=()',
    
    // CSP
    'Content-Security-Policy': [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://vercel.live",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self' data:",
      "connect-src 'self' https://*.supabase.co wss://*.supabase.co https://*.yahoo.com",
      "frame-ancestors 'none'",
      "base-uri 'self'",
      "form-action 'self'",
      "upgrade-insecure-requests",
    ].join('; '),
  }
  
  Object.entries(headers).forEach(([key, value]) => {
    response.headers.set(key, value)
  })
  
  return response
}
```

## 9. セキュリティ監査とログ

### 9.1 監査ログ実装

```typescript
// lib/audit.ts
import { prisma } from '@/lib/prisma'

interface AuditLogEntry {
  userId?: string
  action: string
  resource: string
  resourceId?: string
  metadata?: Record<string, any>
  ipAddress?: string
  userAgent?: string
}

export async function createAuditLog(entry: AuditLogEntry) {
  try {
    await prisma.auditLog.create({
      data: {
        ...entry,
        metadata: entry.metadata ? JSON.stringify(entry.metadata) : null,
        timestamp: new Date(),
      },
    })
  } catch (error) {
    console.error('Failed to create audit log:', error)
    // Send to external logging service
  }
}

// 使用例
export async function deletePortfolio(
  portfolioId: string,
  userId: string,
  req: Request
) {
  const portfolio = await prisma.portfolio.delete({
    where: { id: portfolioId },
  })
  
  await createAuditLog({
    userId,
    action: 'DELETE',
    resource: 'portfolio',
    resourceId: portfolioId,
    metadata: { portfolioName: portfolio.name },
    ipAddress: req.headers.get('x-forwarded-for') ?? 'unknown',
    userAgent: req.headers.get('user-agent') ?? 'unknown',
  })
  
  return portfolio
}
```

### 9.2 セキュリティイベント監視

```typescript
// lib/security-monitor.ts
import { createAuditLog } from './audit'

export class SecurityMonitor {
  private failedAttempts = new Map<string, number>()
  private readonly MAX_ATTEMPTS = 5
  private readonly WINDOW_MS = 15 * 60 * 1000 // 15 minutes
  
  async trackFailedLogin(email: string, ip: string) {
    const key = `${email}:${ip}`
    const attempts = (this.failedAttempts.get(key) || 0) + 1
    this.failedAttempts.set(key, attempts)
    
    if (attempts >= this.MAX_ATTEMPTS) {
      await this.handleSecurityEvent('BRUTE_FORCE_ATTEMPT', {
        email,
        ip,
        attempts,
      })
      
      // Block IP or require additional verification
      await this.blockAccess(ip)
    }
    
    // Clear after time window
    setTimeout(() => {
      this.failedAttempts.delete(key)
    }, this.WINDOW_MS)
  }
  
  private async handleSecurityEvent(
    eventType: string,
    data: Record<string, any>
  ) {
    // Log security event
    await createAuditLog({
      action: eventType,
      resource: 'security',
      metadata: data,
    })
    
    // Send alert
    if (eventType === 'BRUTE_FORCE_ATTEMPT') {
      await this.sendSecurityAlert({
        type: eventType,
        severity: 'HIGH',
        data,
      })
    }
  }
  
  private async sendSecurityAlert(alert: any) {
    // Send to monitoring service
    await fetch(process.env.SECURITY_WEBHOOK_URL!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(alert),
    })
  }
  
  private async blockAccess(ip: string) {
    // Add to blocklist
    await prisma.blocklist.create({
      data: {
        ip,
        reason: 'Brute force attempt',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
      },
    })
  }
}
```

## 10. セキュリティチェックリスト

### 10.1 デプロイメント前チェックリスト

```markdown
## Security Deployment Checklist

### Authentication & Authorization
- [ ] Multi-factor authentication enabled
- [ ] Session timeout configured
- [ ] Password complexity requirements enforced
- [ ] Account lockout after failed attempts
- [ ] JWT tokens properly validated and rotated

### Data Protection
- [ ] All sensitive data encrypted at rest
- [ ] TLS 1.3 for all connections
- [ ] Database connections use SSL
- [ ] PII data masked in logs
- [ ] Secure cookie flags set (HttpOnly, Secure, SameSite)

### Input Validation
- [ ] All user inputs validated with Zod
- [ ] File upload restrictions implemented
- [ ] SQL injection prevention verified
- [ ] XSS protection tested
- [ ] Command injection prevented

### API Security
- [ ] Rate limiting configured
- [ ] API authentication required
- [ ] CORS properly configured
- [ ] API versioning implemented
- [ ] Error messages don't leak sensitive info

### Infrastructure
- [ ] WAF configured
- [ ] DDoS protection enabled
- [ ] Security headers verified
- [ ] CSP policy tested
- [ ] HTTPS redirect enforced

### Monitoring
- [ ] Security logging enabled
- [ ] Audit trail implemented
- [ ] Alerting configured
- [ ] Backup strategy tested
- [ ] Incident response plan documented

### Compliance
- [ ] GDPR compliance verified
- [ ] Privacy policy updated
- [ ] Terms of service reviewed
- [ ] Data retention policy implemented
- [ ] Right to deletion implemented
```

### 10.2 定期セキュリティレビュー

```typescript
// scripts/security-check.ts
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)

async function runSecurityAudit() {
  console.log('🔒 Running Security Audit...\n')
  
  // Check for vulnerable dependencies
  console.log('Checking dependencies...')
  const { stdout: auditResult } = await execAsync('pnpm audit')
  console.log(auditResult)
  
  // Check for secrets in code
  console.log('\nScanning for secrets...')
  const { stdout: secretsResult } = await execAsync('truffehog filesystem .')
  console.log(secretsResult || '✅ No secrets found')
  
  // Check security headers
  console.log('\nChecking security headers...')
  const response = await fetch(process.env.PRODUCTION_URL!)
  const headers = response.headers
  
  const requiredHeaders = [
    'X-Content-Type-Options',
    'X-Frame-Options',
    'Content-Security-Policy',
    'Strict-Transport-Security',
  ]
  
  requiredHeaders.forEach(header => {
    if (headers.get(header)) {
      console.log(`✅ ${header}: ${headers.get(header)}`)
    } else {
      console.log(`❌ Missing: ${header}`)
    }
  })
  
  console.log('\n🔒 Security Audit Complete')
}

runSecurityAudit()
```

---
*最終更新日: 2024年12月*
*バージョン: 1.0.0*
