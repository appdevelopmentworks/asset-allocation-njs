# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¬ã‚¤ãƒ‰ - Asset Allocation Tool

## 1. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### 1.1 å¤šå±¤é˜²å¾¡æˆ¦ç•¥

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           WAF (Cloudflare)             â”‚
â”‚     DDoS Protection, Rate Limiting     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Edge Middleware (Vercel)       â”‚
â”‚   Authentication, Authorization, CSP   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Application Layer (Next.js)     â”‚
â”‚   Input Validation, CSRF Protection    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Database (Supabase)            â”‚
â”‚     RLS, Encryption, Audit Logs       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 2. èªè¨¼ãƒ»èªå¯

### 2.1 èªè¨¼ãƒ•ãƒ­ãƒ¼å®Ÿè£…

```typescript
// lib/auth/auth.ts
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import { cache } from 'react'

export const getSession = cache(async () => {
  const cookieStore = cookies()

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
      },
    },
  )

  const {
    data: { session },
    error,
  } = await supabase.auth.getSession()

  if (error) {
    console.error('Session error:', error)
    return null
  }

  return session
})

export const requireAuth = async () => {
  const session = await getSession()

  if (!session) {
    throw new Error('Unauthorized')
  }

  return session
}
```

### 2.2 èªå¯ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢

```typescript
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'

const PUBLIC_ROUTES = ['/', '/login', '/signup', '/api/health']
const ADMIN_ROUTES = ['/admin']

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })

  const {
    data: { session },
  } = await supabase.auth.getSession()

  const isPublicRoute = PUBLIC_ROUTES.includes(req.nextUrl.pathname)
  const isAdminRoute = ADMIN_ROUTES.some((route) => req.nextUrl.pathname.startsWith(route))

  // Redirect if not authenticated and accessing protected route
  if (!session && !isPublicRoute) {
    return NextResponse.redirect(new URL('/login', req.url))
  }

  // Check admin authorization
  if (isAdminRoute && session) {
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', session.user.id)
      .single()

    if (profile?.role !== 'admin') {
      return NextResponse.redirect(new URL('/unauthorized', req.url))
    }
  }

  return res
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}
```

## 3. å…¥åŠ›æ¤œè¨¼ã¨ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³

### 3.1 Zodã‚¹ã‚­ãƒ¼ãƒã«ã‚ˆã‚‹æ¤œè¨¼

```typescript
// lib/validations/portfolio.ts
import { z } from 'zod'

// SQL Injectionå¯¾ç­–
const SafeStringSchema = z.string().regex(/^[a-zA-Z0-9\s\-_.]+$/, 'Invalid characters detected')

// XSSå¯¾ç­–
const sanitizeHtml = (input: string) => {
  return input
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;')
}

export const PortfolioSchema = z.object({
  name: SafeStringSchema.min(1, 'Name is required')
    .max(100, 'Name too long')
    .transform(sanitizeHtml),

  description: z.string().max(500).transform(sanitizeHtml).optional(),

  initialInvestment: z.number().positive('Must be positive').max(1000000000, 'Amount too large'),

  assets: z
    .array(
      z.object({
        symbol: z.string().regex(/^[A-Z0-9\-]{1,10}$/, 'Invalid symbol format'),
        weight: z
          .number()
          .min(0, 'Weight must be non-negative')
          .max(1, 'Weight cannot exceed 100%'),
      }),
    )
    .min(1, 'At least one asset required')
    .max(50, 'Too many assets')
    .refine((assets) => {
      const totalWeight = assets.reduce((sum, a) => sum + a.weight, 0)
      return Math.abs(totalWeight - 1) < 0.001
    }, 'Total weight must equal 100%'),
})

// API Routeä½¿ç”¨ä¾‹
export async function POST(req: Request) {
  try {
    const body = await req.json()
    const validated = PortfolioSchema.parse(body)

    // Validated data is safe to use
    return createPortfolio(validated)
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 },
      )
    }
    throw error
  }
}
```

### 3.2 SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–

```typescript
// lib/db/queries.ts
import { sql } from '@vercel/postgres'

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒªï¼ˆæ¨å¥¨ï¼‰
export async function getPortfolioById(userId: string, portfolioId: string) {
  const result = await sql`
    SELECT * FROM portfolios
    WHERE user_id = ${userId}
    AND id = ${portfolioId}
    AND deleted_at IS NULL
  `
  return result.rows[0]
}

// Prismaä½¿ç”¨ï¼ˆæ¨å¥¨ï¼‰
import { prisma } from '@/lib/prisma'

export async function getPortfolioByIdPrisma(userId: string, portfolioId: string) {
  return await prisma.portfolio.findFirst({
    where: {
      id: portfolioId,
      userId,
      deletedAt: null,
    },
  })
}

// å±é™ºãªä¾‹ï¼ˆä½¿ç”¨ç¦æ­¢ï¼‰
// âŒ Never do this:
// const query = `SELECT * FROM portfolios WHERE id = '${portfolioId}'`
```

## 4. CSRFå¯¾ç­–

### 4.1 CSRFãƒˆãƒ¼ã‚¯ãƒ³å®Ÿè£…

```typescript
// lib/csrf.ts
import crypto from 'crypto'
import { cookies } from 'next/headers'

export function generateCsrfToken(): string {
  return crypto.randomBytes(32).toString('hex')
}

export async function validateCsrfToken(token: string): Promise<boolean> {
  const cookieStore = cookies()
  const storedToken = cookieStore.get('csrf-token')?.value

  if (!storedToken || !token) {
    return false
  }

  // ã‚¿ã‚¤ãƒŸãƒ³ã‚°æ”»æ’ƒå¯¾ç­–
  return crypto.timingSafeEqual(Buffer.from(storedToken), Buffer.from(token))
}

// API Route Protection
export async function protectedApiRoute(req: Request) {
  const token = req.headers.get('X-CSRF-Token')

  if (!token || !(await validateCsrfToken(token))) {
    return NextResponse.json({ error: 'Invalid CSRF token' }, { status: 403 })
  }

  // Process request
}
```

### 4.2 Double Submit Cookie Pattern

```typescript
// components/CsrfProtectedForm.tsx
'use client'

import { useEffect, useState } from 'react'

export function CsrfProtectedForm({ children, onSubmit }) {
  const [csrfToken, setCsrfToken] = useState('')

  useEffect(() => {
    // Get CSRF token from server
    fetch('/api/csrf')
      .then(res => res.json())
      .then(data => setCsrfToken(data.token))
  }, [])

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault()

    const formData = new FormData(e.currentTarget)

    await fetch('/api/portfolio', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': csrfToken,
      },
      body: JSON.stringify(Object.fromEntries(formData)),
    })
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="hidden" name="_csrf" value={csrfToken} />
      {children}
    </form>
  )
}
```

## 5. XSSå¯¾ç­–

### 5.1 Content Security Policy

```typescript
// app/layout.tsx
export const metadata: Metadata = {
  other: {
    'Content-Security-Policy':
      "default-src 'self'; " +
      "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://vercel.live; " +
      "style-src 'self' 'unsafe-inline'; " +
      "img-src 'self' data: https:; " +
      "font-src 'self' data:; " +
      "connect-src 'self' https://*.supabase.co https://*.yahoo.com; " +
      "frame-ancestors 'none'; " +
      "base-uri 'self'; " +
      "form-action 'self';",
  },
}
```

### 5.2 å®‰å…¨ãªHTMLè¡¨ç¤º

```typescript
// components/SafeHtml.tsx
import DOMPurify from 'isomorphic-dompurify'

interface SafeHtmlProps {
  html: string
  allowedTags?: string[]
}

export function SafeHtml({
  html,
  allowedTags = ['p', 'br', 'strong', 'em']
}: SafeHtmlProps) {
  const clean = DOMPurify.sanitize(html, {
    ALLOWED_TAGS: allowedTags,
    ALLOWED_ATTR: [],
  })

  return (
    <div
      dangerouslySetInnerHTML={{ __html: clean }}
      className="prose"
    />
  )
}

// ä½¿ç”¨ä¾‹
<SafeHtml html={userGeneratedContent} />
```

## 6. APIã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### 6.1 Rate Limitingå®Ÿè£…

```typescript
// lib/rate-limit.ts
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
})

// Create different rate limiters for different endpoints
export const rateLimiters = {
  api: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(100, '1 m'),
    analytics: true,
  }),

  auth: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(5, '15 m'),
    analytics: true,
  }),

  expensive: new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(10, '1 h'),
    analytics: true,
  }),
}

// API Route Example
export async function POST(req: Request) {
  const ip = req.headers.get('x-forwarded-for') ?? 'unknown'

  const { success, limit, reset, remaining } = await rateLimiters.api.limit(`api_${ip}`)

  if (!success) {
    return new Response('Too Many Requests', {
      status: 429,
      headers: {
        'X-RateLimit-Limit': limit.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': new Date(reset).toISOString(),
        'Retry-After': Math.floor((reset - Date.now()) / 1000).toString(),
      },
    })
  }

  // Process request
}
```

### 6.2 API Keyç®¡ç†

```typescript
// lib/api-keys.ts
import crypto from 'crypto'
import { prisma } from '@/lib/prisma'

export async function generateApiKey(userId: string): Promise<string> {
  const key = `sk_${crypto.randomBytes(32).toString('hex')}`
  const hashedKey = crypto.createHash('sha256').update(key).digest('hex')

  await prisma.apiKey.create({
    data: {
      userId,
      key: hashedKey,
      prefix: key.substring(0, 7),
      expiresAt: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days
    },
  })

  return key // Return only once to user
}

export async function validateApiKey(key: string): Promise<boolean> {
  const hashedKey = crypto.createHash('sha256').update(key).digest('hex')

  const apiKey = await prisma.apiKey.findUnique({
    where: { key: hashedKey },
    include: { user: true },
  })

  if (!apiKey || apiKey.expiresAt < new Date()) {
    return false
  }

  // Update last used
  await prisma.apiKey.update({
    where: { id: apiKey.id },
    data: { lastUsed: new Date() },
  })

  return true
}
```

## 7. ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–

### 7.1 æš—å·åŒ–ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

```typescript
// lib/crypto.ts
import crypto from 'crypto'

const algorithm = 'aes-256-gcm'
const secretKey = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex')

export function encrypt(text: string): string {
  const iv = crypto.randomBytes(16)
  const cipher = crypto.createCipheriv(algorithm, secretKey, iv)

  let encrypted = cipher.update(text, 'utf8', 'hex')
  encrypted += cipher.final('hex')

  const authTag = cipher.getAuthTag()

  return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted
}

export function decrypt(encryptedData: string): string {
  const parts = encryptedData.split(':')
  const iv = Buffer.from(parts[0], 'hex')
  const authTag = Buffer.from(parts[1], 'hex')
  const encrypted = parts[2]

  const decipher = crypto.createDecipheriv(algorithm, secretKey, iv)
  decipher.setAuthTag(authTag)

  let decrypted = decipher.update(encrypted, 'hex', 'utf8')
  decrypted += decipher.final('utf8')

  return decrypted
}

// ä½¿ç”¨ä¾‹
const sensitiveData = 'user-api-key'
const encrypted = encrypt(sensitiveData)
const decrypted = decrypt(encrypted)
```

### 7.2 ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒ¬ãƒ™ãƒ«æš—å·åŒ–

```typescript
// prisma/middleware.ts
import { PrismaClient } from '@prisma/client'
import { encrypt, decrypt } from '@/lib/crypto'

const prisma = new PrismaClient()

prisma.$use(async (params, next) => {
  // Encrypt sensitive fields before saving
  if (params.model === 'User' && params.action === 'create') {
    if (params.args.data.ssn) {
      params.args.data.ssn = encrypt(params.args.data.ssn)
    }
  }

  const result = await next(params)

  // Decrypt sensitive fields after reading
  if (params.model === 'User' && params.action === 'findUnique') {
    if (result?.ssn) {
      result.ssn = decrypt(result.ssn)
    }
  }

  return result
})

export { prisma }
```

## 8. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼

### 8.1 åŒ…æ‹¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š

```typescript
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const response = NextResponse.next()

  // Security Headers
  const headers = {
    // XSS Protection
    'X-XSS-Protection': '1; mode=block',

    // Prevent MIME type sniffing
    'X-Content-Type-Options': 'nosniff',

    // Referrer Policy
    'Referrer-Policy': 'strict-origin-when-cross-origin',

    // Frame Options (Clickjacking protection)
    'X-Frame-Options': 'DENY',

    // HSTS
    'Strict-Transport-Security': 'max-age=63072000; includeSubDomains; preload',

    // Permissions Policy
    'Permissions-Policy': 'camera=(), microphone=(), geolocation=(), interest-cohort=()',

    // CSP
    'Content-Security-Policy': [
      "default-src 'self'",
      "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://vercel.live",
      "style-src 'self' 'unsafe-inline'",
      "img-src 'self' data: https:",
      "font-src 'self' data:",
      "connect-src 'self' https://*.supabase.co wss://*.supabase.co https://*.yahoo.com",
      "frame-ancestors 'none'",
      "base-uri 'self'",
      "form-action 'self'",
      'upgrade-insecure-requests',
    ].join('; '),
  }

  Object.entries(headers).forEach(([key, value]) => {
    response.headers.set(key, value)
  })

  return response
}
```

## 9. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã¨ãƒ­ã‚°

### 9.1 ç›£æŸ»ãƒ­ã‚°å®Ÿè£…

```typescript
// lib/audit.ts
import { prisma } from '@/lib/prisma'

interface AuditLogEntry {
  userId?: string
  action: string
  resource: string
  resourceId?: string
  metadata?: Record<string, any>
  ipAddress?: string
  userAgent?: string
}

export async function createAuditLog(entry: AuditLogEntry) {
  try {
    await prisma.auditLog.create({
      data: {
        ...entry,
        metadata: entry.metadata ? JSON.stringify(entry.metadata) : null,
        timestamp: new Date(),
      },
    })
  } catch (error) {
    console.error('Failed to create audit log:', error)
    // Send to external logging service
  }
}

// ä½¿ç”¨ä¾‹
export async function deletePortfolio(portfolioId: string, userId: string, req: Request) {
  const portfolio = await prisma.portfolio.delete({
    where: { id: portfolioId },
  })

  await createAuditLog({
    userId,
    action: 'DELETE',
    resource: 'portfolio',
    resourceId: portfolioId,
    metadata: { portfolioName: portfolio.name },
    ipAddress: req.headers.get('x-forwarded-for') ?? 'unknown',
    userAgent: req.headers.get('user-agent') ?? 'unknown',
  })

  return portfolio
}
```

### 9.2 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆç›£è¦–

```typescript
// lib/security-monitor.ts
import { createAuditLog } from './audit'

export class SecurityMonitor {
  private failedAttempts = new Map<string, number>()
  private readonly MAX_ATTEMPTS = 5
  private readonly WINDOW_MS = 15 * 60 * 1000 // 15 minutes

  async trackFailedLogin(email: string, ip: string) {
    const key = `${email}:${ip}`
    const attempts = (this.failedAttempts.get(key) || 0) + 1
    this.failedAttempts.set(key, attempts)

    if (attempts >= this.MAX_ATTEMPTS) {
      await this.handleSecurityEvent('BRUTE_FORCE_ATTEMPT', {
        email,
        ip,
        attempts,
      })

      // Block IP or require additional verification
      await this.blockAccess(ip)
    }

    // Clear after time window
    setTimeout(() => {
      this.failedAttempts.delete(key)
    }, this.WINDOW_MS)
  }

  private async handleSecurityEvent(eventType: string, data: Record<string, any>) {
    // Log security event
    await createAuditLog({
      action: eventType,
      resource: 'security',
      metadata: data,
    })

    // Send alert
    if (eventType === 'BRUTE_FORCE_ATTEMPT') {
      await this.sendSecurityAlert({
        type: eventType,
        severity: 'HIGH',
        data,
      })
    }
  }

  private async sendSecurityAlert(alert: any) {
    // Send to monitoring service
    await fetch(process.env.SECURITY_WEBHOOK_URL!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(alert),
    })
  }

  private async blockAccess(ip: string) {
    // Add to blocklist
    await prisma.blocklist.create({
      data: {
        ip,
        reason: 'Brute force attempt',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000),
      },
    })
  }
}
```

## 10. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### 10.1 ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆå‰ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

```markdown
## Security Deployment Checklist

### Authentication & Authorization

- [ ] Multi-factor authentication enabled
- [ ] Session timeout configured
- [ ] Password complexity requirements enforced
- [ ] Account lockout after failed attempts
- [ ] JWT tokens properly validated and rotated

### Data Protection

- [ ] All sensitive data encrypted at rest
- [ ] TLS 1.3 for all connections
- [ ] Database connections use SSL
- [ ] PII data masked in logs
- [ ] Secure cookie flags set (HttpOnly, Secure, SameSite)

### Input Validation

- [ ] All user inputs validated with Zod
- [ ] File upload restrictions implemented
- [ ] SQL injection prevention verified
- [ ] XSS protection tested
- [ ] Command injection prevented

### API Security

- [ ] Rate limiting configured
- [ ] API authentication required
- [ ] CORS properly configured
- [ ] API versioning implemented
- [ ] Error messages don't leak sensitive info

### Infrastructure

- [ ] WAF configured
- [ ] DDoS protection enabled
- [ ] Security headers verified
- [ ] CSP policy tested
- [ ] HTTPS redirect enforced

### Monitoring

- [ ] Security logging enabled
- [ ] Audit trail implemented
- [ ] Alerting configured
- [ ] Backup strategy tested
- [ ] Incident response plan documented

### Compliance

- [ ] GDPR compliance verified
- [ ] Privacy policy updated
- [ ] Terms of service reviewed
- [ ] Data retention policy implemented
- [ ] Right to deletion implemented
```

### 10.2 å®šæœŸã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ“ãƒ¥ãƒ¼

```typescript
// scripts/security-check.ts
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)

async function runSecurityAudit() {
  console.log('ğŸ”’ Running Security Audit...\n')

  // Check for vulnerable dependencies
  console.log('Checking dependencies...')
  const { stdout: auditResult } = await execAsync('pnpm audit')
  console.log(auditResult)

  // Check for secrets in code
  console.log('\nScanning for secrets...')
  const { stdout: secretsResult } = await execAsync('truffehog filesystem .')
  console.log(secretsResult || 'âœ… No secrets found')

  // Check security headers
  console.log('\nChecking security headers...')
  const response = await fetch(process.env.PRODUCTION_URL!)
  const headers = response.headers

  const requiredHeaders = [
    'X-Content-Type-Options',
    'X-Frame-Options',
    'Content-Security-Policy',
    'Strict-Transport-Security',
  ]

  requiredHeaders.forEach((header) => {
    if (headers.get(header)) {
      console.log(`âœ… ${header}: ${headers.get(header)}`)
    } else {
      console.log(`âŒ Missing: ${header}`)
    }
  })

  console.log('\nğŸ”’ Security Audit Complete')
}

runSecurityAudit()
```

---

_æœ€çµ‚æ›´æ–°æ—¥: 2024å¹´12æœˆ_
_ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 1.0.0_
