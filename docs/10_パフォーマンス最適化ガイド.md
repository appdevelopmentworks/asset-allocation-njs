# パフォーマンス最適化ガイド - Asset Allocation Tool

## 1. パフォーマンス目標

### 1.1 Core Web Vitals目標値

| メトリクス                     | 目標値  | 現在値 | 状態 |
| ------------------------------ | ------- | ------ | ---- |
| LCP (Largest Contentful Paint) | < 2.5s  | -      | -    |
| FID (First Input Delay)        | < 100ms | -      | -    |
| CLS (Cumulative Layout Shift)  | < 0.1   | -      | -    |
| FCP (First Contentful Paint)   | < 1.8s  | -      | -    |
| TTFB (Time to First Byte)      | < 600ms | -      | -    |
| TTI (Time to Interactive)      | < 3.8s  | -      | -    |

### 1.2 カスタムメトリクス

```typescript
// lib/performance.ts
export const PERFORMANCE_TARGETS = {
  // API Response Times
  apiResponseTime: 200, // ms
  databaseQueryTime: 50, // ms
  cacheHitRate: 0.8, // 80%

  // Frontend Metrics
  bundleSize: 500, // KB
  imageLoadTime: 1000, // ms
  chartRenderTime: 500, // ms

  // Business Metrics
  portfolioLoadTime: 2000, // ms
  optimizationTime: 3000, // ms
  searchResponseTime: 300, // ms
}
```

## 2. Next.js最適化

### 2.1 画像最適化

```typescript
// components/OptimizedImage.tsx
import Image from 'next/image'

interface OptimizedImageProps {
  src: string
  alt: string
  priority?: boolean
  className?: string
}

export function OptimizedImage({
  src,
  alt,
  priority = false,
  className,
}: OptimizedImageProps) {
  return (
    <Image
      src={src}
      alt={alt}
      width={800}
      height={600}
      priority={priority}
      placeholder="blur"
      blurDataURL={generateBlurDataURL()}
      quality={85}
      className={className}
      sizes="(max-width: 640px) 100vw,
             (max-width: 1024px) 50vw,
             33vw"
      loading={priority ? 'eager' : 'lazy'}
    />
  )
}

// Blur placeholder generator
function generateBlurDataURL(): string {
  const canvas = document.createElement('canvas')
  canvas.width = 10
  canvas.height = 10
  const ctx = canvas.getContext('2d')!
  ctx.fillStyle = '#f3f4f6'
  ctx.fillRect(0, 0, 10, 10)
  return canvas.toDataURL()
}
```

### 2.2 動的インポートとコード分割

```typescript
// app/(dashboard)/portfolio/page.tsx
import dynamic from 'next/dynamic'
import { Suspense } from 'react'
import { PortfolioSkeleton } from '@/components/skeletons'

// Heavy components loaded on demand
const EfficiencyFrontier = dynamic(
  () => import('@/components/charts/EfficiencyFrontier'),
  {
    loading: () => <PortfolioSkeleton />,
    ssr: false, // Client-side only for chart libraries
  }
)

const PortfolioOptimizer = dynamic(
  () => import('@/components/portfolio/Optimizer'),
  {
    loading: () => <div>Loading optimizer...</div>,
  }
)

export default function PortfolioPage() {
  return (
    <div>
      <Suspense fallback={<PortfolioSkeleton />}>
        <EfficiencyFrontier />
      </Suspense>

      <Suspense fallback={<div>Loading...</div>}>
        <PortfolioOptimizer />
      </Suspense>
    </div>
  )
}
```

### 2.3 Route Segment Config

```typescript
// app/api/portfolio/optimize/route.ts
export const runtime = 'edge' // Use Edge Runtime for better performance
export const dynamic = 'force-dynamic'
export const revalidate = 0

// app/(dashboard)/analysis/page.tsx
export const runtime = 'nodejs'
export const dynamic = 'force-static'
export const revalidate = 3600 // Revalidate every hour
```

## 3. データベース最適化

### 3.1 クエリ最適化

```typescript
// lib/db/optimized-queries.ts
import { prisma } from '@/lib/prisma'

// N+1問題の解決
export async function getPortfoliosWithAssets(userId: string) {
  return await prisma.portfolio.findMany({
    where: { userId },
    include: {
      assets: {
        include: {
          asset: true, // Eager loading
        },
      },
      _count: {
        select: { assets: true }, // Count without loading
      },
    },
  })
}

// インデックスを活用したクエリ
export async function getAssetPriceHistory(symbol: string, startDate: Date, endDate: Date) {
  return await prisma.$queryRaw`
    SELECT date, close, volume
    FROM asset_prices USE INDEX (idx_asset_prices_symbol_date)
    WHERE symbol = ${symbol}
      AND date >= ${startDate}
      AND date <= ${endDate}
    ORDER BY date DESC
  `
}

// バッチ処理
export async function updateMultiplePortfolios(updates: Array<{ id: string; data: any }>) {
  return await prisma.$transaction(
    updates.map(({ id, data }) =>
      prisma.portfolio.update({
        where: { id },
        data,
      }),
    ),
  )
}
```

### 3.2 接続プール最適化

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
    datasources: {
      db: {
        url: process.env.DATABASE_URL,
      },
    },
  })

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}

// Connection pool configuration in DATABASE_URL:
// postgresql://user:pass@host:5432/db?connection_limit=10&pool_timeout=30
```

## 4. キャッシング戦略

### 4.1 多層キャッシング

```typescript
// lib/cache/multi-layer-cache.ts
import { Redis } from '@upstash/redis'
import { LRUCache } from 'lru-cache'

class MultiLayerCache {
  private memoryCache: LRUCache<string, any>
  private redisCache: Redis

  constructor() {
    // L1 Cache: In-memory
    this.memoryCache = new LRUCache({
      max: 500,
      ttl: 1000 * 60 * 5, // 5 minutes
      updateAgeOnGet: true,
      updateAgeOnHas: true,
    })

    // L2 Cache: Redis
    this.redisCache = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL!,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    })
  }

  async get<T>(key: string): Promise<T | null> {
    // Check L1 (Memory)
    const memoryHit = this.memoryCache.get(key)
    if (memoryHit) {
      return memoryHit as T
    }

    // Check L2 (Redis)
    const redisHit = await this.redisCache.get(key)
    if (redisHit) {
      // Promote to L1
      this.memoryCache.set(key, redisHit)
      return redisHit as T
    }

    return null
  }

  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    // Set in both layers
    this.memoryCache.set(key, value)
    await this.redisCache.setex(key, ttl, JSON.stringify(value))
  }

  async invalidate(pattern: string): Promise<void> {
    // Clear from memory cache
    for (const key of this.memoryCache.keys()) {
      if (key.includes(pattern)) {
        this.memoryCache.delete(key)
      }
    }

    // Clear from Redis
    const keys = await this.redisCache.keys(pattern)
    if (keys.length > 0) {
      await this.redisCache.del(...keys)
    }
  }
}

export const cache = new MultiLayerCache()
```

### 4.2 API Route Caching

```typescript
// app/api/assets/[symbol]/route.ts
import { cache } from '@/lib/cache/multi-layer-cache'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(req: NextRequest, { params }: { params: { symbol: string } }) {
  const cacheKey = `asset:${params.symbol}`

  // Try cache first
  const cached = await cache.get(cacheKey)
  if (cached) {
    return NextResponse.json(cached, {
      headers: {
        'X-Cache': 'HIT',
        'Cache-Control': 'public, max-age=60',
      },
    })
  }

  // Fetch fresh data
  const data = await fetchAssetData(params.symbol)

  // Cache for different durations based on asset type
  const ttl = getAssetCacheTTL(data.type)
  await cache.set(cacheKey, data, ttl)

  return NextResponse.json(data, {
    headers: {
      'X-Cache': 'MISS',
      'Cache-Control': `public, max-age=${ttl}`,
    },
  })
}

function getAssetCacheTTL(assetType: string): number {
  const ttlMap = {
    stock: 60, // 1 minute for stocks
    etf: 300, // 5 minutes for ETFs
    bond: 3600, // 1 hour for bonds
    crypto: 30, // 30 seconds for crypto
  }
  return ttlMap[assetType] || 60
}
```

## 5. フロントエンド最適化

### 5.1 React最適化

```typescript
// components/optimized/MemoizedComponent.tsx
import { memo, useMemo, useCallback } from 'react'

interface PortfolioCardProps {
  portfolio: Portfolio
  onUpdate: (id: string, data: any) => void
}

export const PortfolioCard = memo(
  ({ portfolio, onUpdate }: PortfolioCardProps) => {
    // Memoize expensive calculations
    const metrics = useMemo(() => {
      return calculatePortfolioMetrics(portfolio)
    }, [portfolio.assets, portfolio.lastUpdated])

    // Memoize callbacks
    const handleUpdate = useCallback(
      (data: any) => {
        onUpdate(portfolio.id, data)
      },
      [portfolio.id, onUpdate]
    )

    return (
      <div className="portfolio-card">
        <h3>{portfolio.name}</h3>
        <MetricsDisplay metrics={metrics} />
        <button onClick={handleUpdate}>Update</button>
      </div>
    )
  },
  // Custom comparison function
  (prevProps, nextProps) => {
    return (
      prevProps.portfolio.id === nextProps.portfolio.id &&
      prevProps.portfolio.lastUpdated === nextProps.portfolio.lastUpdated
    )
  }
)

PortfolioCard.displayName = 'PortfolioCard'
```

### 5.2 仮想化リスト

```typescript
// components/VirtualizedAssetList.tsx
import { FixedSizeList } from 'react-window'
import AutoSizer from 'react-virtualized-auto-sizer'

interface VirtualizedAssetListProps {
  assets: Asset[]
  onAssetClick: (asset: Asset) => void
}

export function VirtualizedAssetList({
  assets,
  onAssetClick,
}: VirtualizedAssetListProps) {
  const Row = ({ index, style }) => {
    const asset = assets[index]
    return (
      <div
        style={style}
        className="flex items-center p-2 hover:bg-gray-100"
        onClick={() => onAssetClick(asset)}
      >
        <span className="font-medium">{asset.symbol}</span>
        <span className="ml-2 text-gray-600">{asset.name}</span>
      </div>
    )
  }

  return (
    <AutoSizer>
      {({ height, width }) => (
        <FixedSizeList
          height={height}
          width={width}
          itemCount={assets.length}
          itemSize={50}
          overscanCount={5}
        >
          {Row}
        </FixedSizeList>
      )}
    </AutoSizer>
  )
}
```

### 5.3 デバウンスとスロットリング

```typescript
// hooks/useOptimizedSearch.ts
import { useState, useCallback, useRef } from 'react'
import { debounce, throttle } from 'lodash'

export function useOptimizedSearch() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])
  const abortControllerRef = useRef<AbortController>()

  // Debounced search for text input
  const debouncedSearch = useCallback(
    debounce(async (searchQuery: string) => {
      // Cancel previous request
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }

      // Create new abort controller
      abortControllerRef.current = new AbortController()

      try {
        const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`, {
          signal: abortControllerRef.current.signal,
        })

        if (response.ok) {
          const data = await response.json()
          setResults(data)
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Search error:', error)
        }
      }
    }, 300),
    [],
  )

  // Throttled scroll handler
  const throttledScroll = useCallback(
    throttle((event: Event) => {
      const scrollPosition = window.scrollY
      // Handle scroll
    }, 100),
    [],
  )

  return {
    query,
    setQuery,
    results,
    search: debouncedSearch,
    handleScroll: throttledScroll,
  }
}
```

## 6. Web Worker最適化

### 6.1 計算処理のオフロード

```typescript
// workers/portfolio-calculator.worker.ts
import { calculateSharpeRatio, calculateVolatility } from '@/lib/calculations'

self.addEventListener('message', async (event) => {
  const { type, data } = event.data

  switch (type) {
    case 'CALCULATE_METRICS':
      const metrics = {
        sharpeRatio: calculateSharpeRatio(data.returns),
        volatility: calculateVolatility(data.returns),
        // Other heavy calculations
      }
      self.postMessage({ type: 'METRICS_RESULT', data: metrics })
      break

    case 'OPTIMIZE_PORTFOLIO':
      const optimized = await heavyOptimizationAlgorithm(data)
      self.postMessage({ type: 'OPTIMIZATION_RESULT', data: optimized })
      break
  }
})

// hooks/useWorker.ts
import { useEffect, useRef, useState } from 'react'

export function usePortfolioWorker() {
  const workerRef = useRef<Worker>()
  const [result, setResult] = useState(null)
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    workerRef.current = new Worker(
      new URL('../workers/portfolio-calculator.worker.ts', import.meta.url),
    )

    workerRef.current.addEventListener('message', (event) => {
      setResult(event.data.data)
      setLoading(false)
    })

    return () => {
      workerRef.current?.terminate()
    }
  }, [])

  const calculate = useCallback((data: any) => {
    setLoading(true)
    workerRef.current?.postMessage({
      type: 'CALCULATE_METRICS',
      data,
    })
  }, [])

  return { result, loading, calculate }
}
```

## 7. Bundle最適化

### 7.1 Bundle Analyzer設定

```javascript
// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})

module.exports = withBundleAnalyzer({
  experimental: {
    optimizePackageImports: ['lodash', 'date-fns', 'recharts', '@radix-ui/react-*'],
  },

  webpack: (config, { isServer }) => {
    // Tree shaking optimization
    config.optimization.usedExports = true
    config.optimization.sideEffects = false

    // Split chunks
    if (!isServer) {
      config.optimization.splitChunks = {
        chunks: 'all',
        cacheGroups: {
          default: false,
          vendors: false,
          framework: {
            chunks: 'all',
            name: 'framework',
            test: /(?<!node_modules.*)[\\/]node_modules[\\/](react|react-dom|scheduler|prop-types|use-subscription)[\\/]/,
            priority: 40,
            enforce: true,
          },
          lib: {
            test(module) {
              return module.size() > 160000 && /node_modules[/\\]/.test(module.identifier())
            },
            name(module) {
              const hash = crypto.createHash('sha1')
              hash.update(module.identifier())
              return hash.digest('hex').substring(0, 8)
            },
            priority: 30,
            minChunks: 1,
            reuseExistingChunk: true,
          },
          commons: {
            name: 'commons',
            minChunks: 2,
            priority: 20,
          },
          shared: {
            name(module, chunks) {
              return (
                crypto
                  .createHash('sha1')
                  .update(chunks.reduce((acc, chunk) => acc + chunk.name, ''))
                  .digest('hex') + (isServer ? '-server' : '')
              )
            },
            priority: 10,
            minChunks: 2,
            reuseExistingChunk: true,
          },
        },
        maxInitialRequests: 25,
        minSize: 20000,
      }
    }

    return config
  },
})
```

### 7.2 動的インポート最適化

```typescript
// lib/dynamic-imports.ts
export const importChart = () => import(/* webpackChunkName: "charts" */ '@/components/charts')

export const importOptimizer = () =>
  import(/* webpackChunkName: "optimizer" */ '@/lib/calculations/optimizer')

export const importPlotly = () => import(/* webpackChunkName: "plotly" */ 'plotly.js-basic-dist')

// Preload critical chunks
export function preloadCriticalChunks() {
  if (typeof window !== 'undefined') {
    // Preload chart library
    const link = document.createElement('link')
    link.rel = 'preload'
    link.as = 'script'
    link.href = '/_next/static/chunks/charts.js'
    document.head.appendChild(link)
  }
}
```

## 8. API最適化

### 8.1 GraphQL DataLoader Pattern

```typescript
// lib/dataloaders/AssetLoader.ts
import DataLoader from 'dataloader'
import { prisma } from '@/lib/prisma'

export class AssetLoader {
  private loader: DataLoader<string, Asset>

  constructor() {
    this.loader = new DataLoader(
      async (symbols: readonly string[]) => {
        const assets = await prisma.asset.findMany({
          where: {
            symbol: { in: [...symbols] },
          },
        })

        // Map results to maintain order
        const assetMap = new Map(assets.map((asset) => [asset.symbol, asset]))

        return symbols.map(
          (symbol) => assetMap.get(symbol) || new Error(`Asset ${symbol} not found`),
        )
      },
      {
        cache: true,
        cacheKeyFn: (key) => key.toUpperCase(),
        maxBatchSize: 100,
      },
    )
  }

  async load(symbol: string): Promise<Asset> {
    return this.loader.load(symbol)
  }

  async loadMany(symbols: string[]): Promise<Asset[]> {
    return this.loader.loadMany(symbols)
  }

  clearCache(symbol?: string) {
    if (symbol) {
      this.loader.clear(symbol)
    } else {
      this.loader.clearAll()
    }
  }
}
```

## 9. モニタリングとプロファイリング

### 9.1 パフォーマンスモニタリング

```typescript
// lib/monitoring/performance.ts
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map()

  startTimer(label: string): () => void {
    const start = performance.now()

    return () => {
      const duration = performance.now() - start
      this.recordMetric(label, duration)
    }
  }

  recordMetric(label: string, value: number) {
    if (!this.metrics.has(label)) {
      this.metrics.set(label, [])
    }

    const values = this.metrics.get(label)!
    values.push(value)

    // Keep only last 100 measurements
    if (values.length > 100) {
      values.shift()
    }

    // Log if exceeds threshold
    const threshold = PERFORMANCE_TARGETS[label]
    if (threshold && value > threshold) {
      console.warn(`Performance warning: ${label} took ${value}ms (threshold: ${threshold}ms)`)
      this.reportToAnalytics(label, value)
    }
  }

  getStats(label: string) {
    const values = this.metrics.get(label) || []
    if (values.length === 0) return null

    const sorted = [...values].sort((a, b) => a - b)
    return {
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    }
  }

  private reportToAnalytics(label: string, value: number) {
    // Send to monitoring service
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', 'timing_complete', {
        name: label,
        value: Math.round(value),
        event_category: 'Performance',
      })
    }
  }
}

export const perfMonitor = new PerformanceMonitor()
```

### 9.2 使用例

```typescript
// app/api/portfolio/optimize/route.ts
import { perfMonitor } from '@/lib/monitoring/performance'

export async function POST(req: Request) {
  const endTimer = perfMonitor.startTimer('portfolio_optimization')

  try {
    // Parse request
    const parseEnd = perfMonitor.startTimer('request_parsing')
    const body = await req.json()
    parseEnd()

    // Database query
    const dbEnd = perfMonitor.startTimer('database_query')
    const assetData = await fetchAssetData(body.assets)
    dbEnd()

    // Optimization calculation
    const calcEnd = perfMonitor.startTimer('optimization_calculation')
    const result = await optimizePortfolio(assetData, body.options)
    calcEnd()

    return NextResponse.json(result)
  } finally {
    endTimer()
  }
}
```

## 10. チェックリスト

### 10.1 パフォーマンス最適化チェックリスト

```markdown
## Performance Optimization Checklist

### Build Time

- [ ] Bundle size < 500KB (gzipped)
- [ ] Code splitting implemented
- [ ] Tree shaking enabled
- [ ] Unused dependencies removed
- [ ] Production build optimized

### Runtime

- [ ] Lazy loading for images
- [ ] Virtual scrolling for long lists
- [ ] Debouncing/throttling for events
- [ ] Web Workers for heavy computation
- [ ] Request cancellation implemented

### Caching

- [ ] Static assets cached
- [ ] API responses cached
- [ ] Database queries optimized
- [ ] CDN configured
- [ ] Service Worker implemented

### Monitoring

- [ ] Core Web Vitals tracked
- [ ] Custom metrics defined
- [ ] Performance budgets set
- [ ] Alerts configured
- [ ] Regular performance audits

### SEO

- [ ] Meta tags optimized
- [ ] Structured data added
- [ ] Sitemap generated
- [ ] Robots.txt configured
- [ ] Open Graph tags added
```

---

_最終更新日: 2024年12月_
_バージョン: 1.0.0_
