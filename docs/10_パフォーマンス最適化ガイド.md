# パフォーマンス最適化ガイド - Asset Allocation Tool

## 1. パフォーマンス目標

### 1.1 Core Web Vitals目標値
| メトリクス | 目標値 | 現在値 | 状態 |
|-----------|--------|--------|------|
| LCP (Largest Contentful Paint) | < 2.5s | - | - |
| FID (First Input Delay) | < 100ms | - | - |
| CLS (Cumulative Layout Shift) | < 0.1 | - | - |
| FCP (First Contentful Paint) | < 1.8s | - | - |
| TTFB (Time to First Byte) | < 600ms | - | - |
| TTI (Time to Interactive) | < 3.8s | - | - |

### 1.2 カスタムメトリクス
```typescript
// lib/performance.ts
export const PERFORMANCE_TARGETS = {
  // API Response Times
  apiResponseTime: 200, // ms
  databaseQueryTime: 50, // ms
  cacheHitRate: 0.8, // 80%
  
  // Frontend Metrics
  bundleSize: 500, // KB
  imageLoadTime: 1000, // ms
  chartRenderTime: 500, // ms
  
  // Business Metrics
  portfolioLoadTime: 2000, // ms
  optimizationTime: 3000, // ms
  searchResponseTime: 300, // ms
}
```

## 2. Next.js最適化

### 2.1 画像最適化

```typescript
// components/OptimizedImage.tsx
import Image from 'next/image'

interface OptimizedImageProps {
  src: string
  alt: string
  priority?: boolean
  className?: string
}

export function OptimizedImage({
  src,
  alt,
  priority = false,
  className,
}: OptimizedImageProps) {
  return (
    <Image
      src={src}
      alt={alt}
      width={800}
      height={600}
      priority={priority}
      placeholder="blur"
      blurDataURL={generateBlurDataURL()}
      quality={85}
      className={className}
      sizes="(max-width: 640px) 100vw,
             (max-width: 1024px) 50vw,
             33vw"
      loading={priority ? 'eager' : 'lazy'}
    />
  )
}

// Blur placeholder generator
function generateBlurDataURL(): string {
  const canvas = document.createElement('canvas')
  canvas.width = 10
  canvas.height = 10
  const ctx = canvas.getContext('2d')!
  ctx.fillStyle = '#f3f4f6'
  ctx.fillRect(0, 0, 10, 10)
  return canvas.toDataURL()
}
```

### 2.2 動的インポートとコード分割

```typescript
// app/(dashboard)/portfolio/page.tsx
import dynamic from 'next/dynamic'
import { Suspense } from 'react'
import { PortfolioSkeleton } from '@/components/skeletons'

// Heavy components loaded on demand
const EfficiencyFrontier = dynamic(
  () => import('@/components/charts/EfficiencyFrontier'),
  {
    loading: () => <PortfolioSkeleton />,
    ssr: false, // Client-side only for chart libraries
  }
)

const PortfolioOptimizer = dynamic(
  () => import('@/components/portfolio/Optimizer'),
  {
    loading: () => <div>Loading optimizer...</div>,
  }
)

export default function PortfolioPage() {
  return (
    <div>
      <Suspense fallback={<PortfolioSkeleton />}>
        <EfficiencyFrontier />
      </Suspense>
      
      <Suspense fallback={<div>Loading...</div>}>
        <PortfolioOptimizer />
      </Suspense>
    </div>
  )
}
```

### 2.3 Route Segment Config

```typescript
// app/api/portfolio/optimize/route.ts
export const runtime = 'edge' // Use Edge Runtime for better performance
export const dynamic = 'force-dynamic'
export const revalidate = 0

// app/(dashboard)/analysis/page.tsx
export const runtime = 'nodejs'
export const dynamic = 'force-static'
export const revalidate = 3600 // Revalidate every hour
```

## 3. データベース最適化

### 3.1 クエリ最適化

```typescript
// lib/db/optimized-queries.ts
import { prisma } from '@/lib/prisma'

// N+1問題の解決
export async function getPortfoliosWithAssets(userId: string) {
  return await prisma.portfolio.findMany({
    where: { userId },
    include: {
      assets: {
        include: {
          asset: true, // Eager loading
        },
      },
      _count: {
        select: { assets: true }, // Count without loading
      },
    },
  })
}

// インデックスを活用したクエリ
export async function getAssetPriceHistory(
  symbol: string,
  startDate: Date,
  endDate: Date
) {
  return await prisma.$queryRaw`
    SELECT date, close, volume
    FROM asset_prices USE INDEX (idx_asset_prices_symbol_date)
    WHERE symbol = ${symbol}
      AND date >= ${startDate}
      AND date <= ${endDate}
    ORDER BY date DESC
  `
}

// バッチ処理
export async function updateMultiplePortfolios(
  updates: Array<{ id: string; data: any }>
) {
  return await prisma.$transaction(
    updates.map(({ id, data }) =>
      prisma.portfolio.update({
        where: { id },
        data,
      })
    )
  )
}
```

### 3.2 接続プール最適化

```typescript
// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? 
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' 
      ? ['query', 'error', 'warn'] 
      : ['error'],
    datasources: {
      db: {
        url: process.env.DATABASE_URL,
      },
    },
  })

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}

// Connection pool configuration in DATABASE_URL:
// postgresql://user:pass@host:5432/db?connection_limit=10&pool_timeout=30
```

## 4. キャッシング戦略

### 4.1 多層キャッシング

```typescript
// lib/cache/multi-layer-cache.ts
import { Redis } from '@upstash/redis'
import { LRUCache } from 'lru-cache'

class MultiLayerCache {
  private memoryCache: LRUCache<string, any>
  private redisCache: Redis
  
  constructor() {
    // L1 Cache: In-memory
    this.memoryCache = new LRUCache({
      max: 500,
      ttl: 1000 * 60 * 5, // 5 minutes
      updateAgeOnGet: true,
      updateAgeOnHas: true,
    })
    
    // L2 Cache: Redis
    this.redisCache = new Redis({
      url: process.env.UPSTASH_REDIS_REST_URL!,
      token: process.env.UPSTASH_REDIS_REST_TOKEN!,
    })
  }
  
  async get<T>(key: string): Promise<T | null> {
    // Check L1 (Memory)
    const memoryHit = this.memoryCache.get(key)
    if (memoryHit) {
      return memoryHit as T
    }
    
    // Check L2 (Redis)
    const redisHit = await this.redisCache.get(key)
    if (redisHit) {
      // Promote to L1
      this.memoryCache.set(key, redisHit)
      return redisHit as T
    }
    
    return null
  }
  
  async set(
    key: string,
    value: any,
    ttl: number = 3600
  ): Promise<void> {
    // Set in both layers
    this.memoryCache.set(key, value)
    await this.redisCache.setex(key, ttl, JSON.stringify(value))
  }
  
  async invalidate(pattern: string): Promise<void> {
    // Clear from memory cache
    for (const key of this.memoryCache.keys()) {
      if (key.includes(pattern)) {
        this.memoryCache.delete(key)
      }
    }
    
    // Clear from Redis
    const keys = await this.redisCache.keys(pattern)
    if (keys.length > 0) {
      await this.redisCache.del(...keys)
    }
  }
}

export const cache = new MultiLayerCache()
```

### 4.2 API Route Caching

```typescript
// app/api/assets/[symbol]/route.ts
import { cache } from '@/lib/cache/multi-layer-cache'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(
  req: NextRequest,
  { params }: { params: { symbol: string } }
) {
  const cacheKey = `asset:${params.symbol}`
  
  // Try cache first
  const cached = await cache.get(cacheKey)
  if (cached) {
    return NextResponse.json(cached, {
      headers: {
        'X-Cache': 'HIT',
        'Cache-Control': 'public, max-age=60',
      },
    })
  }
  
  // Fetch fresh data
  const data = await fetchAssetData(params.symbol)
  
  // Cache for different durations based on asset type
  const ttl = getAssetCacheTTL(data.type)
  await cache.set(cacheKey, data, ttl)
  
  return NextResponse.json(data, {
    headers: {
      'X-Cache': 'MISS',
      'Cache-Control': `public, max-age=${ttl}`,
    },
  })
}

function getAssetCacheTTL(assetType: string): number {
  const ttlMap = {
    stock: 60,      // 1 minute for stocks
    etf: 300,       // 5 minutes for ETFs
    bond: 3600,     // 1 hour for bonds
    crypto: 30,     // 30 seconds for crypto
  }
  return ttlMap[assetType] || 60
}
```

## 5. フロントエンド最適化

### 5.1 React最適化

```typescript
// components/optimized/MemoizedComponent.tsx
import { memo, useMemo, useCallback } from 'react'

interface PortfolioCardProps {
  portfolio: Portfolio
  onUpdate: (id: string, data: any) => void
}

export const PortfolioCard = memo(
  ({ portfolio, onUpdate }: PortfolioCardProps) => {
    // Memoize expensive calculations
    const metrics = useMemo(() => {
      return calculatePortfolioMetrics(portfolio)
    }, [portfolio.assets, portfolio.lastUpdated])
    
    // Memoize callbacks
    const handleUpdate = useCallback(
      (data: any) => {
        onUpdate(portfolio.id, data)
      },
      [portfolio.id, onUpdate]
    )
    
    return (
      <div className="portfolio-card">
        <h3>{portfolio.name}</h3>
        <MetricsDisplay metrics={metrics} />
        <button onClick={handleUpdate}>Update</button>
      </div>
    )
  },
  // Custom comparison function
  (prevProps, nextProps) => {
    return (
      prevProps.portfolio.id === nextProps.portfolio.id &&
      prevProps.portfolio.lastUpdated === nextProps.portfolio.lastUpdated
    )
  }
)

PortfolioCard.displayName = 'PortfolioCard'
```

### 5.2 仮想化リスト

```typescript
// components/VirtualizedAssetList.tsx
import { FixedSizeList } from 'react-window'
import AutoSizer from 'react-virtualized-auto-sizer'

interface VirtualizedAssetListProps {
  assets: Asset[]
  onAssetClick: (asset: Asset) => void
}

export function VirtualizedAssetList({
  assets,
  onAssetClick,
}: VirtualizedAssetListProps) {
  const Row = ({ index, style }) => {
    const asset = assets[index]
    return (
      <div
        style={style}
        className="flex items-center p-2 hover:bg-gray-100"
        onClick={() => onAssetClick(asset)}
      >
        <span className="font-medium">{asset.symbol}</span>
        <span className="ml-2 text-gray-600">{asset.name}</span>
      </div>
    )
  }
  
  return (
    <AutoSizer>
      {({ height, width }) => (
        <FixedSizeList
          height={height}
          width={width}
          itemCount={assets.length}
          itemSize={50}
          overscanCount={5}
        >
          {Row}
        </FixedSizeList>
      )}
    </AutoSizer>
  )
}
```

### 5.3 デバウンスとスロットリング

```typescript
// hooks/useOptimizedSearch.ts
import { useState, useCallback, useRef } from 'react'
import { debounce, throttle } from 'lodash'

export function useOptimizedSearch() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])
  const abortControllerRef = useRef<AbortController>()
  
  // Debounced search for text input
  const debouncedSearch = useCallback(
    debounce(async (searchQuery: string) => {
      // Cancel previous request
      if (abortControllerRef.current) {
        abortControllerRef.current.abort()
      }
      
      // Create new abort controller
      abortControllerRef.current = new AbortController()
      
      try {
        const response = await fetch(
          `/api/search?q=${encodeURIComponent(searchQuery)}`,
          { signal: abortControllerRef.current.signal }
        )
        
        if (response.ok) {
          const data = await response.json()
          setResults(data)
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Search error:', error)
        }
      }
    }, 300),
    []
  )
  
  // Throttled scroll handler
  const throttledScroll = useCallback(
    throttle((event: Event) => {
      const scrollPosition = window.scrollY
      // Handle scroll
    }, 100),
    []
  )
  
  return {
    query,
    setQuery,
    results,
    search: debouncedSearch,
    handleScroll: throttledScroll,
  }
}
```

## 6. Web Worker最適化

### 6.1 計算処理のオフロード

```typescript
// workers/portfolio-calculator.worker.ts
import { calculateSharpeRatio, calculateVolatility } from '@/lib/calculations'

self.addEventListener('message', async (event) => {
  const { type, data } = event.data
  
  switch (type) {
    case 'CALCULATE_METRICS':
      const metrics = {
        sharpeRatio: calculateSharpeRatio(data.returns),
        volatility: calculateVolatility(data.returns),
        // Other heavy calculations
      }
      self.postMessage({ type: 'METRICS_RESULT', data: metrics })
      break
      
    case 'OPTIMIZE_PORTFOLIO':
      const optimized = await heavyOptimizationAlgorithm(data)
      self.postMessage({ type: 'OPTIMIZATION_RESULT', data: optimized })
      break
  }
})

// hooks/useWorker.ts
import { useEffect, useRef, useState } from 'react'

export function usePortfolioWorker() {
  const workerRef = useRef<Worker>()
  const [result, setResult] = useState(null)
  const [loading, setLoading] = useState(false)
  
  useEffect(() => {
    workerRef.current = new Worker(
      new URL('../workers/portfolio-calculator.worker.ts', import.meta.url)
    )
    
    workerRef.current.addEventListener('message', (event) => {
      setResult(event.data.data)
      setLoading(false)
    })
    
    return () => {
      workerRef.current?.terminate()
    }
  }, [])
  
  const calculate = useCallback((data: any) => {
    setLoading(true)
    workerRef.current?.postMessage({
      type: 'CALCULATE_METRICS',
      data,
    })
  }, [])
  
  return { result, loading, calculate }
}
```

## 7. Bundle最適化

### 7.1 Bundle Analyzer設定

```javascript
// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})

module.exports = withBundleAnalyzer({
  experimental: {
    optimizePackageImports: [
      'lodash',
      'date-fns',
      'recharts',
      '@radix-ui/react-*',
    ],
  },
  
  webpack: (config, { isServer }) => {
    // Tree shaking optimization
    config.optimization.usedExports = true
    config.optimization.sideEffects = false
    
    // Split chunks
    if (!isServer) {
      config.optimization.splitChunks = {
        chunks: 'all',
        cacheGroups: {
          default: false,
          vendors: false,
          framework: {
            chunks: 'all',
            name: 'framework',
            test: /(?<!node_modules.*)[\\/]node_modules[\\/](react|react-dom|scheduler|prop-types|use-subscription)[\\/]/,
            priority: 40,
            enforce: true,
          },
          lib: {
            test(module) {
              return module.size() > 160000 &&
                /node_modules[/\\]/.test(module.identifier())
            },
            name(module) {
              const hash = crypto.createHash('sha1')
              hash.update(module.identifier())
              return hash.digest('hex').substring(0, 8)
            },
            priority: 30,
            minChunks: 1,
            reuseExistingChunk: true,
          },
          commons: {
            name: 'commons',
            minChunks: 2,
            priority: 20,
          },
          shared: {
            name(module, chunks) {
              return crypto
                .createHash('sha1')
                .update(chunks.reduce((acc, chunk) => acc + chunk.name, ''))
                .digest('hex') + (isServer ? '-server' : '')
            },
            priority: 10,
            minChunks: 2,
            reuseExistingChunk: true,
          },
        },
        maxInitialRequests: 25,
        minSize: 20000,
      }
    }
    
    return config
  },
})
```

### 7.2 動的インポート最適化

```typescript
// lib/dynamic-imports.ts
export const importChart = () => 
  import(/* webpackChunkName: "charts" */ '@/components/charts')

export const importOptimizer = () =>
  import(/* webpackChunkName: "optimizer" */ '@/lib/calculations/optimizer')

export const importPlotly = () =>
  import(/* webpackChunkName: "plotly" */ 'plotly.js-basic-dist')

// Preload critical chunks
export function preloadCriticalChunks() {
  if (typeof window !== 'undefined') {
    // Preload chart library
    const link = document.createElement('link')
    link.rel = 'preload'
    link.as = 'script'
    link.href = '/_next/static/chunks/charts.js'
    document.head.appendChild(link)
  }
}
```

## 8. API最適化

### 8.1 GraphQL DataLoader Pattern

```typescript
// lib/dataloaders/AssetLoader.ts
import DataLoader from 'dataloader'
import { prisma } from '@/lib/prisma'

export class AssetLoader {
  private loader: DataLoader<string, Asset>
  
  constructor() {
    this.loader = new DataLoader(
      async (symbols: readonly string[]) => {
        const assets = await prisma.asset.findMany({
          where: {
            symbol: { in: [...symbols] },
          },
        })
        
        // Map results to maintain order
        const assetMap = new Map(
          assets.map(asset => [asset.symbol, asset])
        )
        
        return symbols.map(symbol => 
          assetMap.get(symbol) || new Error(`Asset ${symbol} not found`)
        )
      },
      {
        cache: true,
        cacheKeyFn: (key) => key.toUpperCase(),
        maxBatchSize: 100,
      }
    )
  }
  
  async load(symbol: string): Promise<Asset> {
    return this.loader.load(symbol)
  }
  
  async loadMany(symbols: string[]): Promise<Asset[]> {
    return this.loader.loadMany(symbols)
  }
  
  clearCache(symbol?: string) {
    if (symbol) {
      this.loader.clear(symbol)
    } else {
      this.loader.clearAll()
    }
  }
}
```

## 9. モニタリングとプロファイリング

### 9.1 パフォーマンスモニタリング

```typescript
// lib/monitoring/performance.ts
export class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map()
  
  startTimer(label: string): () => void {
    const start = performance.now()
    
    return () => {
      const duration = performance.now() - start
      this.recordMetric(label, duration)
    }
  }
  
  recordMetric(label: string, value: number) {
    if (!this.metrics.has(label)) {
      this.metrics.set(label, [])
    }
    
    const values = this.metrics.get(label)!
    values.push(value)
    
    // Keep only last 100 measurements
    if (values.length > 100) {
      values.shift()
    }
    
    // Log if exceeds threshold
    const threshold = PERFORMANCE_TARGETS[label]
    if (threshold && value > threshold) {
      console.warn(`Performance warning: ${label} took ${value}ms (threshold: ${threshold}ms)`)
      this.reportToAnalytics(label, value)
    }
  }
  
  getStats(label: string) {
    const values = this.metrics.get(label) || []
    if (values.length === 0) return null
    
    const sorted = [...values].sort((a, b) => a - b)
    return {
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)],
    }
  }
  
  private reportToAnalytics(label: string, value: number) {
    // Send to monitoring service
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', 'timing_complete', {
        name: label,
        value: Math.round(value),
        event_category: 'Performance',
      })
    }
  }
}

export const perfMonitor = new PerformanceMonitor()
```

### 9.2 使用例

```typescript
// app/api/portfolio/optimize/route.ts
import { perfMonitor } from '@/lib/monitoring/performance'

export async function POST(req: Request) {
  const endTimer = perfMonitor.startTimer('portfolio_optimization')
  
  try {
    // Parse request
    const parseEnd = perfMonitor.startTimer('request_parsing')
    const body = await req.json()
    parseEnd()
    
    // Database query
    const dbEnd = perfMonitor.startTimer('database_query')
    const assetData = await fetchAssetData(body.assets)
    dbEnd()
    
    // Optimization calculation
    const calcEnd = perfMonitor.startTimer('optimization_calculation')
    const result = await optimizePortfolio(assetData, body.options)
    calcEnd()
    
    return NextResponse.json(result)
  } finally {
    endTimer()
  }
}
```

## 10. チェックリスト

### 10.1 パフォーマンス最適化チェックリスト

```markdown
## Performance Optimization Checklist

### Build Time
- [ ] Bundle size < 500KB (gzipped)
- [ ] Code splitting implemented
- [ ] Tree shaking enabled
- [ ] Unused dependencies removed
- [ ] Production build optimized

### Runtime
- [ ] Lazy loading for images
- [ ] Virtual scrolling for long lists
- [ ] Debouncing/throttling for events
- [ ] Web Workers for heavy computation
- [ ] Request cancellation implemented

### Caching
- [ ] Static assets cached
- [ ] API responses cached
- [ ] Database queries optimized
- [ ] CDN configured
- [ ] Service Worker implemented

### Monitoring
- [ ] Core Web Vitals tracked
- [ ] Custom metrics defined
- [ ] Performance budgets set
- [ ] Alerts configured
- [ ] Regular performance audits

### SEO
- [ ] Meta tags optimized
- [ ] Structured data added
- [ ] Sitemap generated
- [ ] Robots.txt configured
- [ ] Open Graph tags added
```

---
*最終更新日: 2024年12月*
*バージョン: 1.0.0*
